최종판

<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>프리미엄 한자 학습 카드 (클라우드 연동)</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Spoqa+Han+Sans+Neo:wght@400;700&family=Maru+Buri:wght@400;600&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg-dark: #2c2c44; --bg-med: #3e3e5a; --bg-light: #4a4a6a;
            --text-main: #f2c5ca; --text-light: #e0e0f0; --accent-cyan: #81e6d9;
            --accent-cyan-dark: #4fd1c5; --accent-coral: #f5a38c; --correct: #68d391;
            --incorrect: #fc8181; --shadow-light: rgba(255, 255, 255, 0.1);
            --shadow-dark: rgba(0, 0, 0, 0.4);
        }
        body { 
            font-family: 'Spoqa Han Sans Neo', sans-serif; 
            background-color: var(--bg-dark); 
            color: var(--text-light); 
            -webkit-tap-highlight-color: transparent; 
        }
        .hanja-font { 
            font-family: 'Maru Buri', serif; 
            text-shadow: 2px 2px 8px rgba(0,0,0,0.3);
        }
        
        #auth-view, #main-view, #speed-quiz-view, #type-learning-view, #detail-view, #network-view, #news-link-view, #wordbook-view, #wordbook-detail-view, #study-view { 
            transition: opacity 0.4s, transform 0.4s, visibility 0.4s; 
            transition-timing-function: cubic-bezier(0.25, 1, 0.5, 1);
        }
        .hidden-view { 
            opacity: 0; visibility: hidden; transform: translateY(20px); 
            position: absolute; width: 100%; top: 0; left: 0; pointer-events: none;
        }
        
        #news-link-view:not(.hidden-view) {
            position: fixed;
            inset: 0;
            z-index: 40; /* Just below modals */
        }

        .card-container { perspective: 2000px; position: relative; }
        .card { 
            position: relative; width: 100%; height: 100%; 
            transition: transform 0.8s, box-shadow 0.4s; 
            transform-style: preserve-3d; border-radius: 1.5rem; 
        }
        .card-face { 
            position: absolute; width: 100%; height: 100%; 
            -webkit-backface-visibility: hidden; backface-visibility: hidden; 
            display: flex; flex-direction: column; justify-content: center; 
            align-items: center; border-radius: 1.5rem; 
            background: linear-gradient(145deg, var(--bg-light), var(--bg-med));
            box-shadow: 12px 12px 24px var(--shadow-dark), -12px -12px 24px var(--shadow-light);
            border: 1px solid rgba(255, 255, 255, 0.05);
            padding: 1.5rem;
        }
        .card-face.has-badges { padding-top: 4.5rem; }
        .card-back { transform: rotateY(180deg); }
        .is-flipped { transform: rotateY(180deg); }

        .btn-neumorphic {
            background: linear-gradient(145deg, var(--bg-light), var(--bg-med));
            border-radius: 12px;
            border: 1px solid var(--bg-med);
            border-top-color: rgba(255,255,255,0.08);
            border-left-color: rgba(255,255,255,0.08);
            transition: all 0.2s ease-out;
            color: var(--text-light);
            font-weight: 700;
            outline: none;
            text-shadow: 1px 1px 2px var(--shadow-dark);
            box-shadow: 5px 5px 10px var(--shadow-dark), -5px -5px 10px var(--shadow-light);
        }
        .btn-neumorphic:hover {
            transform: translateY(-2px);
            box-shadow: 7px 7px 14px var(--shadow-dark), -7px -7px 14px var(--shadow-light);
            color: var(--text-main);
        }
        .btn-neumorphic:active, .btn-neumorphic:disabled {
            transform: translateY(1px);
            box-shadow: inset 5px 5px 10px var(--shadow-dark), inset -5px -5px 10px var(--shadow-light);
            background: var(--bg-med);
            color: var(--text-main);
        }
        .btn-neumorphic.active {
            transform: translateY(1px);
            box-shadow: inset 5px 5px 10px var(--shadow-dark), inset -5px -5px 10px var(--shadow-light);
            background: var(--bg-dark);
            color: var(--accent-cyan);
        }
        
        .control-panel {
            background-color: var(--bg-dark);
            border-radius: 12px;
            padding: 6px;
            box-shadow: inset 5px 5px 10px var(--shadow-dark), inset -5px -5px 10px var(--shadow-light);
        }
        .control-panel > div {
            scrollbar-width: none; /* Firefox */
        }
        .control-panel > div::-webkit-scrollbar {
            display: none; /* Safari and Chrome */
        }
        .control-panel button {
            flex-shrink: 0; margin: 0 2px;
            background: var(--bg-light); border: 1px solid var(--bg-med);
            border-bottom: 3px solid #1e1e2c; color: var(--text-light);
            white-space: nowrap; border-radius: 8px; font-weight: 700;
            transition: all 0.1s ease-in-out; 
            padding: 5px 8px; font-size: 0.8rem;
        }
        .control-panel #mode-selector button {
            padding: 5px 10px; font-size: 0.85rem;
        }
        .control-panel button:active {
            transform: translateY(2px); border-bottom-width: 1px;
        }
        .control-panel button.active {
            background: var(--bg-med); color: var(--text-main);
            border-color: var(--bg-dark); border-bottom-color: var(--accent-cyan);
            transform: translateY(2px); border-bottom-width: 1px;
        }

        .check-btn { font-size: 0.75rem; padding: 0.5rem 0.75rem; }
        .check-btn.correct { background: var(--correct); border-bottom-color: #38a169; }
        .check-btn.incorrect { background: var(--incorrect); border-bottom-color: #c53030; }
        
        #write-canvas, #writing-quiz-canvas { background-color: #e5e7eb; border-radius: 0.5rem; cursor: crosshair; touch-action: none; }
        
        #timer-bar { 
            height: 6px; background: linear-gradient(90deg, var(--accent-cyan), var(--accent-cyan-dark)); 
            width: 100%; transform-origin: left; transition: transform 0.1s linear; 
            box-shadow: 0 0 10px var(--accent-cyan);
        }
        
        .card-back-content { scrollbar-width: none; }
        .card-back-content::-webkit-scrollbar { display: none; }
        .card-back-content p { font-size: 1.1rem; line-height: 1.6; }
        .card-back-content h3 { margin-bottom: 0.25rem; font-size: 0.9rem; color: var(--accent-cyan); }
        .card-back-content .huneum-text { font-size: 2rem; color: var(--text-main); }
        .ai-output { font-size: 1.1rem; line-height: 1.6; color: #d1d5db; white-space: pre-wrap; }

        .info-badge {
            background-color: rgba(0, 0, 0, 0.4); padding: 0.5rem 1rem; border-radius: 9999px;
            font-size: 1rem; font-weight: 700; color: var(--text-light);
            box-shadow: inset 2px 2px 4px rgba(0,0,0,0.4), 1px 1px 2px rgba(0,0,0,0.3);
            border: 1px solid rgba(255, 255, 255, 0.05); transition: all 0.2s;
        }
        .info-badge.clickable { cursor: pointer; }
        .info-badge.clickable:hover {
            background-color: var(--accent-cyan); color: var(--bg-dark);
            transform: translateY(-1px); box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        .info-badge-container {
            position: absolute; top: 1.25rem; left: 1.25rem; right: 1.25rem;
            display: flex; justify-content: space-between; align-items: center; pointer-events: none;
        }
        .info-badge-container > * { pointer-events: all; }
        
        .study-count-badge {
            position: absolute; bottom: 1rem; left: 1rem;
            background-color: rgba(0,0,0,0.3); color: var(--accent-cyan);
            font-size: 0.75rem; font-weight: bold; padding: 0.25rem 0.6rem;
            border-radius: 9999px; pointer-events: none;
        }
        
        .stat-card {
            background: linear-gradient(145deg, var(--bg-light), var(--bg-med));
            border-radius: 1rem; padding: 1rem;
            box-shadow: 8px 8px 16px var(--shadow-dark), -8px -8px 16px var(--shadow-light);
        }
        .representative-card {
            width: 100px; height: 100px; flex-shrink: 0;
            background: linear-gradient(145deg, var(--bg-light), var(--bg-med));
            border-radius: 1rem; display: flex; justify-content: center; align-items: center;
            font-size: 4rem; color: var(--text-main);
            box-shadow: 8px 8px 16px var(--shadow-dark), -8px -8px 16px var(--shadow-light);
            cursor: pointer; transition: transform 0.2s, box-shadow 0.2s;
        }
        .related-cards-grid {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 0.75rem;
        }
        .small-card-container {
            perspective: 1000px; aspect-ratio: 1 / 1; cursor: pointer;
        }
        .small-card {
            position: relative; width: 100%; height: 100%;
            transition: transform 0.6s; transform-style: preserve-3d;
        }
        .small-card.is-flipped { transform: rotateY(180deg); }
        .small-card-face {
            position: absolute; width: 100%; height: 100%;
            -webkit-backface-visibility: hidden; backface-visibility: hidden;
            display: flex; justify-content: center; align-items: center; border-radius: 0.75rem;
            background: linear-gradient(145deg, var(--bg-light), var(--bg-med));
            box-shadow: 4px 4px 8px var(--shadow-dark), -4px -4px 8px var(--shadow-light);
        }
        .small-card-front { font-size: 2rem; color: var(--text-light); }
        .small-card-front.word { font-size: 1.5rem; letter-spacing: 0.1em; padding: 0 4px; }
        .small-card-back { 
            transform: rotateY(180deg); 
            text-align: center; 
            padding: 4px; 
            color: var(--accent-cyan); 
            flex-direction: column;
            line-height: 1.2;
            font-size: 0.8rem;
        }
        .small-card-back .reason { font-size: 0.7rem; color: var(--text-light); }
        .small-card-back .hanja { font-size: 1.5rem; }

        .paja-animation-container {
            position: relative; height: 60px; display: flex; justify-content: center;
            align-items: center; font-family: 'Maru Buri', serif; font-size: 2.5rem;
            color: var(--text-light); margin: 1rem 0;
        }
        .paja-component, .paja-plus, .paja-final {
            position: absolute;
            transition: all 0.8s cubic-bezier(0.68, -0.55, 0.27, 1.55);
        }
        .paja-final { opacity: 0; transform: scale(0.5); color: var(--accent-cyan); }
        .paja-plus { opacity: 1; font-size: 1.5rem; color: var(--text-main); }
        .paja-animation-container.animate .paja-component,
        .paja-animation-container.animate .paja-plus { transform: translateX(0) scale(0.8); opacity: 0; }
        .paja-animation-container.animate .paja-final { opacity: 1; transform: scale(1.2); transition-delay: 0.5s; }
        
        #quiz-slider {
            -webkit-appearance: none; appearance: none;
            width: 100%; height: 8px;
            background: var(--bg-dark);
            outline: none; border-radius: 4px;
            box-shadow: inset 3px 3px 6px var(--shadow-dark), inset -3px -3px 6px var(--shadow-light);
        }
        #quiz-slider::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none;
            width: 24px; height: 24px;
            background: var(--accent-cyan);
            cursor: pointer; border-radius: 50%;
            box-shadow: 4px 4px 8px var(--shadow-dark), -4px -4px 8px var(--shadow-light);
        }
        #quiz-slider::-moz-range-thumb {
            width: 24px; height: 24px;
            background: var(--accent-cyan);
            cursor: pointer; border-radius: 50%;
            box-shadow: 4px 4px 8px var(--shadow-dark), -4px -4px 8px var(--shadow-light);
        }
        #stroke-guide-canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }
        /* Network View Styles */
        .network-node {
            transform-origin: center;
            cursor: pointer;
        }
        .node-face {
            text-anchor: middle;
            dominant-baseline: central;
            fill: var(--text-main);
            font-family: 'Maru Buri', serif;
            pointer-events: none;
        }
        .node-front { font-size: 2rem; }
        .node-back { font-size: 0.8rem; fill: var(--text-light); }
        .network-shortcut-btn {
            position: absolute; bottom: 1rem; right: 1rem; z-index: 10;
            padding: 0.75rem; border-radius: 9999px;
        }
        #network-tooltip {
            position: fixed; background-color: var(--bg-dark); color: var(--accent-cyan);
            padding: 0.5rem 1rem; border-radius: 0.5rem; box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            border: 1px solid var(--bg-light); font-size: 1.1rem; font-weight: bold; z-index: 100;
            pointer-events: none; transition: opacity 0.2s, transform 0.2s;
            transform: translate(-50%, -100%) translateY(-10px); opacity: 0;
        }
        #network-tooltip.visible {
            transform: translate(-50%, -100%) translateY(0); opacity: 1;
        }
        
        .btn-quiz-type {
            background: linear-gradient(145deg, var(--bg-light), var(--bg-med));
            box-shadow: 5px 5px 10px var(--shadow-dark), -5px -5px 10px var(--shadow-light);
            transition: all 0.15s ease-out;
            border: 1px solid rgba(0,0,0,0.2);
            border-radius: 12px;
            color: var(--text-light);
            font-weight: 700;
        }
        .btn-quiz-type:hover {
            transform: translateY(-2px);
            box-shadow: 8px 8px 16px var(--shadow-dark), -8px -8px 16px var(--shadow-light);
            color: var(--text-main);
        }
        .btn-quiz-type:active {
            background: var(--bg-med);
            box-shadow: inset 5px 5px 10px var(--shadow-dark), inset -5px -5px 10px var(--shadow-light);
            transform: translateY(1px);
            color: var(--accent-cyan);
        }
        
        /* Wordbook Styles */
        #wordbook-list {
            display: flex;
            flex-wrap: wrap;
            gap: 0.4rem;
            align-content: flex-start;
            scrollbar-width: none;
        }
        #wordbook-list::-webkit-scrollbar {
            display: none;
        }
        .wordbook-card {
            background: var(--bg-light);
            border-radius: 9999px;
            padding: 0.4rem 1rem;
            cursor: pointer;
            user-select: none;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 4px 4px 8px var(--shadow-dark), -4px -4px 8px var(--shadow-light);
            white-space: nowrap;
        }
        .wordbook-card .word-content {
            transition: opacity 0.3s;
            text-align: center;
        }
        .wordbook-card .word-hanja {
            font-size: 1rem;
        }
        .wordbook-card .word-hangul {
            font-size: 0.75rem;
            color: var(--accent-cyan);
        }
        .wordbook-card .word-huneum {
            font-size: 0.8rem;
            color: var(--text-light);
            line-height: 1.3;
        }
        .wordbook-card .remove-word-btn {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background: none;
            border: none;
            color: var(--text-light);
            opacity: 0.5;
            font-size: 1.2rem;
            padding: 0.25rem;
            line-height: 1;
        }

        .sort-toggle-btn {
            transition: all 0.2s ease-in-out;
            color: var(--text-light);
            font-weight: 700;
        }
        .sort-toggle-btn.active {
            background: var(--bg-med);
            color: var(--accent-cyan);
            box-shadow: 2px 2px 5px var(--shadow-dark), -2px -2px 5px var(--shadow-light);
        }

    </style>
</head>
<body class="p-4 sm:p-6">

    <div id="auth-view" class="w-full max-w-md mx-auto text-center flex flex-col justify-center h-screen">
        <h1 class="text-4xl font-bold text-text-main mb-4 hanja-font">프리미엄 한자학습</h1>
        <p id="loading-status" class="text-text-light mb-8">연결중...</p>
        <p id="user-id-display" class="text-xs text-gray-500 break-all"></p>
    </div>

    <div id="main-view" class="hidden-view">
        <div class="w-full max-w-xl md:max-w-2xl mx-auto">
            <div class="control-panel mb-6">
                <div id="mode-selector" class="flex overflow-x-auto">
                    <button data-mode="read" class="active">📖 읽기</button>
                    <button data-mode="write">✍️ 쓰기</button>
                    <button data-mode="type">🗂️ 유형</button>
                    <button data-mode="quiz">⚡ 퀴즈</button>
                    <button data-mode="news-link">🔗 뉴스</button>
                    <button data-mode="wordbook">📔 단어장</button>
                    <button data-mode="study">📺 공부</button>
                </div>
                <div id="level-selector" class="flex overflow-x-auto">
                    <button data-level="전체" class="active">전체</button>
                    <button data-level="8급">8급</button>
                    <button data-level="7급">7급</button>
                    <button data-level="6급">6급</button>
                    <button data-level="5급">5급</button>
                    <button data-level="4급">4급</button>
                    <button data-level="3급">3급</button>
                    <button data-level="2급">2급</button>
                    <button data-level="암기">암기</button>
                    <button data-level="미암기">미암기</button>
                    <button data-level="오답">오답</button>
                </div>
            </div>
            
            <div class="card-container w-full aspect-[4/3.9] mb-6">
                <div id="flashcard" class="card">
                    <div id="card-front" class="card-face has-badges"></div>
                    <div id="card-back" class="card-face card-back"></div>
                </div>
                <button id="network-shortcut-btn" class="btn-neumorphic network-shortcut-btn">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="18" cy="5" r="3"></circle><circle cx="6" cy="12" r="3"></circle><circle cx="18" cy="19" r="3"></circle><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line></svg>
                </button>
            </div>

            <div class="flex items-center justify-between w-full space-x-2 mb-2">
                <button id="prev-btn" class="btn-neumorphic p-3 rounded-full flex-shrink-0"><svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" /></svg></button>
                <div id="progress" class="text-base font-bold text-gray-400 px-2 text-center whitespace-nowrap flex-grow"></div>
                <button id="next-btn" class="btn-neumorphic p-3 rounded-full flex-shrink-0"><svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" /></svg></button>
            </div>

            <div class="flex items-center justify-center gap-4">
                <div class="p-1 rounded-full flex items-center bg-bg-dark" style="box-shadow: inset 3px 3px 6px var(--shadow-dark), inset -3px -3px 6px var(--shadow-light);">
                    <button id="sort-btn" class="px-4 py-2 text-sm rounded-full flex items-center gap-2">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3.01" y2="6"></line><line x1="3" y1="12" x2="3.01" y2="12"></line><line x1="3" y1="18" x2="3.01" y2="18"></line></svg>
                        <span>번호순</span>
                    </button>
                    <button id="shuffle-btn" class="px-4 py-2 text-sm rounded-full flex items-center gap-2">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none" viewBox="0 0 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 3h5v5M4 20L20 4M21 16v5h-5M15 15l6 6M4 4l5 5" /></svg>
                        <span>랜덤</span>
                    </button>
                </div>
                <button id="correct-btn" class="btn-neumorphic check-btn correct py-2 px-4 invisible text-sm">✅ 암기</button>
                <button id="incorrect-btn" class="btn-neumorphic check-btn incorrect py-2 px-4 invisible text-sm">❌ 미암기</button>
            </div>
        </div>
    </div>
    
    <div id="type-learning-view" class="hidden-view p-4"></div>
    <div id="detail-view" class="hidden-view p-4"></div>
    <div id="wordbook-view" class="hidden-view p-4"></div>
    <div id="wordbook-detail-view" class="hidden-view p-4"></div>
    <div id="study-view" class="hidden-view p-4"></div>

    <div id="news-link-view" class="hidden-view">
        <div class="w-full h-full mx-auto flex flex-col p-4 sm:p-6">
            <div class="flex justify-between items-center mb-4 flex-shrink-0 gap-2">
                <h1 class="text-2xl sm:text-3xl font-bold text-text-main">한자 뉴스</h1>
                <div class="flex items-center gap-2">
                    <button id="analyze-clipboard-btn" class="btn-neumorphic py-3 px-4 text-sm">기사 분석</button>
                    <button id="home-btn-news-link" class="btn-neumorphic py-3 px-5">🏠</button>
                </div>
            </div>
            <div class="flex-grow w-full h-full bg-white rounded-lg overflow-hidden">
                <iframe id="news-iframe" class="w-full h-full border-none" src="https://hanjaro.juntong.or.kr/page_translater_mobile.aspx?sURL=https%3a%2f%2fnews.daum.net&hh=1&hu=1&hl=111111111"></iframe>
            </div>
        </div>
    </div>

    <div id="speed-quiz-view" class="hidden-view p-4">
        <div class="w-full max-w-md mx-auto flex flex-col justify-center h-screen">
            <div id="quiz-mode-panel" class="text-center">
                <h2 class="text-3xl font-bold mb-6 text-text-main">퀴즈 선택</h2>
                <div class="space-y-4">
                    <button id="quiz-current-scope-btn" class="btn-neumorphic w-full py-4 text-xl">현재 범위 퀴즈</button>
                    <button id="quiz-by-type-btn" class="btn-neumorphic w-full py-4 text-xl">유형별 퀴즈</button>
                    <button id="quiz-writing-btn" class="btn-neumorphic w-full py-4 text-xl">단어장 쓰기</button>
                    <button id="home-btn-quiz-mode" class="btn-neumorphic w-full py-4 text-xl mt-8">홈</button>
                </div>
            </div>
            <div id="writing-quiz-panel" class="hidden w-full h-full flex flex-col justify-center">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-3xl font-bold text-text-main">✍️ 단어장 쓰기</h2>
                    <div id="writing-quiz-progress" class="text-lg font-bold text-text-light"></div>
                </div>
                <p id="writing-quiz-question" class="text-center text-5xl md:text-6xl font-bold text-accent-cyan my-6 h-20"></p>
                <div class="flex-1 min-h-0 relative aspect-square w-full mx-auto mb-2">
                    <canvas id="writing-quiz-canvas" class="w-full h-full"></canvas>
                    <div id="writing-quiz-answer-display" class="absolute inset-0 flex justify-center items-center text-red-500 hanja-font text-8xl md:text-9xl pointer-events-none" style="opacity: 0.8;"></div>
                </div>
                <div id="writing-quiz-controls" class="space-y-2 mt-4">
                    <div class="grid grid-cols-2 gap-2">
                        <button id="clear-writing-quiz-canvas-btn" class="btn-neumorphic py-3">지우기</button>
                        <button id="next-writing-quiz-btn" class="btn-neumorphic py-3">다음</button>
                    </div>
                    <div id="writing-quiz-action-container" class="grid grid-cols-1 gap-2">
                        <button id="check-writing-quiz-answer-btn" class="btn-neumorphic py-3 bg-accent-cyan text-bg-dark">정답 확인</button>
                        <div id="writing-quiz-mark-btns" class="hidden grid grid-cols-2 gap-2">
                            <button id="writing-quiz-correct-btn" class="btn-neumorphic check-btn correct py-3">✅ 암기</button>
                            <button id="writing-quiz-incorrect-btn" class="btn-neumorphic check-btn incorrect py-3">❌ 미암기</button>
                        </div>
                    </div>
                </div>
                <button id="home-btn-writing-quiz" class="btn-neumorphic w-full py-3 mt-4">홈</button>
            </div>
            <div id="quiz-type-selection-panel" class="hidden text-center flex flex-col h-full justify-center">
                <h2 class="text-3xl font-bold mb-6 text-text-main flex-shrink-0">유형 선택</h2>
                <div id="quiz-type-selector-bar" class="flex-grow overflow-y-auto"></div>
                <button id="back-to-quiz-mode-btn" class="btn-neumorphic w-full py-4 text-xl mt-8 flex-shrink-0">뒤로</button>
            </div>
            <div id="quiz-setup-panel" class="hidden text-center">
                <h2 class="text-3xl font-bold mb-2 text-text-main">퀴즈 설정</h2>
                <p class="mb-6 text-text-light">문제 수를 선택하세요.</p>
                <div class="mb-8 px-4">
                    <div class="flex justify-between items-center mb-2">
                        <span class="text-lg font-bold text-text-light">문제 수:</span>
                        <span id="quiz-count-label" class="text-2xl font-bold text-accent-cyan">10</span>
                    </div>
                    <input id="quiz-slider" type="range" min="10" max="100" value="10" step="10">
                </div>
                <div class="grid grid-cols-2 gap-4">
                    <button id="home-btn-quiz-setup" class="btn-neumorphic py-4 text-xl">홈</button>
                    <button id="start-quiz-btn" class="btn-neumorphic py-4 text-xl bg-accent-cyan text-bg-dark">시작</button>
                </div>
            </div>
            <div id="quiz-main-panel" class="hidden">
                <div class="mb-4">
                    <div id="timer-bar-container" class="w-full bg-gray-700 rounded-full h-2.5 overflow-hidden">
                        <div id="timer-bar" class="bg-accent-cyan h-2.5 rounded-full"></div>
                    </div>
                    <div class="flex justify-between items-center mt-2">
                        <div class="w-1/3"></div>
                        <div id="quiz-progress" class="text-center text-lg font-bold text-text-light w-1/3"></div>
                        <div class="w-1/3 flex justify-end">
                            <button id="home-btn-quiz" class="btn-neumorphic py-2 px-4">🏠</button>
                        </div>
                    </div>
                </div>
                <div id="quiz-hanja" class="hanja-font text-9xl text-center mb-8 text-white"></div>
                <div id="quiz-options" class="grid grid-cols-2 gap-4"></div>
            </div>
            <div id="quiz-end-panel" class="hidden text-center">
                <h2 class="text-4xl font-bold mb-4 text-text-main">결과</h2>
                <p id="quiz-final-score" class="text-2xl mb-2 text-white"></p>
                <p id="quiz-accuracy" class="text-xl mb-8 text-accent-cyan"></p>
                <div class="grid grid-cols-2 gap-4">
                    <button id="retry-quiz-btn" class="btn-neumorphic py-4">재도전</button>
                    <button id="home-btn-quiz-end" class="btn-neumorphic py-4">홈</button>
                </div>
            </div>
        </div>
    </div>
    
    <div id="network-view" class="hidden-view p-4">
        <div class="w-full max-w-4xl mx-auto">
            <div class="flex justify-between items-center mb-6">
                <h1 class="text-3xl font-bold text-text-main">한자 네트워크</h1>
                <button id="home-btn-network" class="btn-neumorphic py-3 px-5">학습 복귀</button>
            </div>
            <div id="hanja-network-graph" class="w-full h-[85vh] relative"></div>
        </div>
    </div>

    <div id="custom-modal-overlay" class="fixed inset-0 bg-black bg-opacity-60 hidden items-center justify-center z-50 p-4">
        <div id="custom-modal-content" class="bg-bg-med p-6 rounded-2xl shadow-lg max-w-sm w-full mx-4 text-center">
            <div id="custom-modal-message"></div>
            <div id="modal-buttons" class="grid grid-cols-1 gap-4 mt-6">
                <!-- Buttons are dynamically inserted here -->
            </div>
        </div>
    </div>

    <div id="network-tooltip"></div>

    <script type="module">
        // Firebase Imports (Updated to version 11.6.1)
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, serverTimestamp, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Firebase 설정 ---
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-hanja-app-cloud';

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        setLogLevel('debug');

        // App state variables
        let hanjaData = [];
        let hanjaMap = new Map();
        let similarShapesData = {};
        let relatedMeaningData = {};
        let strokeData = {};
        let knownAnswers = new Set();
        let incorrectAnswers = new Set();
        let userWordbook = new Map(); // Changed from Set to Map
        let learningStats = { studyCount: {}, history: [], totalTime: 0, lastIdiomQuizDate: null };
        let userId = null;
        let isAppInitialized = false;
        let lastStateFromCloud = null;
        
        // DOM Elements
        const authView = document.getElementById('auth-view');
        const loadingStatus = document.getElementById('loading-status');
        const userIdDisplay = document.getElementById('user-id-display');
        const mainView = document.getElementById('main-view');
        const card = document.getElementById('flashcard');
        const cardFront = document.getElementById('card-front');
        const cardBack = document.getElementById('card-back');
        const modeSelector = document.getElementById('mode-selector');
        const progressEl = document.getElementById('progress');
        const levelSelector = document.getElementById('level-selector');
        const typeLearningView = document.getElementById('type-learning-view');
        const detailView = document.getElementById('detail-view');
        const speedQuizView = document.getElementById('speed-quiz-view');
        const networkView = document.getElementById('network-view');
        const newsLinkView = document.getElementById('news-link-view');
        const wordbookView = document.getElementById('wordbook-view');
        const studyView = document.getElementById('study-view');
        const networkTooltip = document.getElementById('network-tooltip');
        const correctBtn = document.getElementById('correct-btn');
        const incorrectBtn = document.getElementById('incorrect-btn');
        
        let currentIndex = 0;
        let isFlipped = false;
        let filteredHanjaData = [];
        let currentMode = 'read';
        let currentLevel = '전체';
        let currentHanjaData = null;
        let previousState = null;
        let mainLearningState = null; 
        let currentTypePage = 0;
        let typeViewScrollPos = 0;
        let networkViewScrollPos = 0;
        let previousView = '';
        
        // Quiz state
        let currentQuizType = ''; // 'multiple-choice' or 'writing'
        let quizSourceData = [];
        let quizData = [];
        let currentQuizIndex = 0;
        let quizScore = 0;
        let timerInterval;
        const QUIZ_TIME = 5;
        let selectedQuizCount = 10;
        let writingQuizData = [];
        let currentWritingQuizIndex = 0;

        let sessionStartTime = null;
        let networkState = { lastClickedHanja: null, currentCenter: null };
        let isTypeQuizMode = false;
        let wordbookDisplayMode = 'hanja'; // 'hanja' or 'hangul'
        
        // --- 데이터 관리 로직 ---
        let firestoreUnsubscribe = null;

        async function saveDataToFirestore() {
            if (!userId) return;
            try {
                const docRef = doc(db, 'artifacts', appId, 'users', userId);
                await setDoc(docRef, {
                    knownAnswers: Array.from(knownAnswers),
                    incorrectAnswers: Array.from(incorrectAnswers),
                    userWordbook: Object.fromEntries(userWordbook), // Convert Map to Object
                    learningStats: learningStats,
                    lastUpdated: serverTimestamp()
                }, { merge: true });
            } catch (error) {
                console.error("Error saving data to Firestore:", error);
            }
        }

        async function saveLastStateToFirestore() {
            if (!userId || !isAppInitialized) return;
            try {
                const stateToSave = {
                    mode: currentMode,
                    level: currentLevel,
                    hanjaNo: currentHanjaData ? currentHanjaData.no : null,
                };
                const docRef = doc(db, 'artifacts', appId, 'users', userId);
                await setDoc(docRef, { lastState: stateToSave }, { merge: true });
            } catch (error) {
                console.error("Error saving last state:", error);
            }
        }

        function setupFirestoreListener() {
            if (firestoreUnsubscribe) firestoreUnsubscribe();
            if (!userId) return;

            const docRef = doc(db, 'artifacts', appId, 'users', userId);
            firestoreUnsubscribe = onSnapshot(docRef, (docSnap) => {
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    knownAnswers = new Set(data.knownAnswers || []);
                    incorrectAnswers = new Set(data.incorrectAnswers || []);
                    userWordbook = new Map(Object.entries(data.userWordbook || {})); // Convert Object to Map
                    learningStats = data.learningStats || { studyCount: {}, history: [], totalTime: 0, lastIdiomQuizDate: null };
                    lastStateFromCloud = data.lastState || null;
                } else {
                    knownAnswers = new Set();
                    incorrectAnswers = new Set();
                    userWordbook = new Map();
                    learningStats = { studyCount: {}, history: [], totalTime: 0, lastIdiomQuizDate: null };
                    lastStateFromCloud = null;
                }
                
                if (!isAppInitialized) {
                    initializeAppUI();
                    isAppInitialized = true;
                }
            }, (error) => {
                console.error("Firestore onSnapshot Error:", error);
                loadingStatus.textContent = "클라우드 데이터 로딩 실패. 새로고침 해주세요.";
            });
        }

        async function fetchAllData() {
            try {
                loadingStatus.textContent = "데이터 로딩중...";
                const [hanjaResponse, strokeResponse, similarResponse, meaningResponse] = await Promise.all([
                    fetch('https://wifikim-cloud.github.io/hanja-app-data/hanja_data.json'),
                    fetch('https://wifikim-cloud.github.io/hanja-app-data/stroke_data.json'),
                    fetch('https://wifikim-cloud.github.io/hanja-app-data/similar_shapes.json'),
                    fetch('https://wifikim-cloud.github.io/hanja-app-data/related_meaning.json')
                ]);

                if (!hanjaResponse.ok) throw new Error(`필수 한자 데이터 로딩 실패: ${hanjaResponse.status}`);
                const hanjaJson = await hanjaResponse.json();
                if (!Array.isArray(hanjaJson) || hanjaJson.length < 2) throw new Error("잘못된 한자 데이터 형식");

                hanjaData = hanjaJson.slice(1).map(item => ({
                    no: parseInt(item.A, 10), hanja: item.B, level: item.C, typeNo: parseInt(item.D, 10),
                    huneum: item.E, paja: item.F, note: item.G
                }));
                hanjaMap = new Map(hanjaData.map(h => [h.hanja, h]));

                loadingStatus.textContent = "추가 데이터 로딩...";
                if (strokeResponse.ok) strokeData = await strokeResponse.json();
                else console.warn('필순 데이터 로딩 실패.');

                if (similarResponse.ok) similarShapesData = await similarResponse.json();
                else console.warn('유사 모양자 데이터 로딩 실패.');

                if (meaningResponse.ok) relatedMeaningData = await meaningResponse.json();
                else console.warn('유의/반의어 데이터 로딩 실패.');


            } catch (error) {
                loadingStatus.textContent = `데이터 로딩 실패: ${error.message}`;
                throw error;
            }
        }
        
        function trackStudyEvent(hanjaNo) {
            if (!hanjaNo) return;
            const today = new Date().toISOString().split('T')[0];
            learningStats.studyCount[hanjaNo] = (learningStats.studyCount[hanjaNo] || 0) + 1;
            
            if (!learningStats.history.find(item => item.date === today && item.hanjaNo === hanjaNo)) {
                learningStats.history.push({ date: today, hanjaNo: hanjaNo });
            }
            saveDataToFirestore();
        }

        function updateCard() {
            if (filteredHanjaData.length === 0) {
                cardFront.innerHTML = `<div class="text-2xl text-center p-4">선택된 급수의 한자가 없거나<br>오답노트가 비어있습니다.</div>`;
                cardBack.innerHTML = '';
                progressEl.textContent = '0 / 0';
                correctBtn.classList.add('invisible');
                incorrectBtn.classList.add('invisible');
                currentHanjaData = null;
                saveLastStateToFirestore();
                return;
            }
            if (currentIndex >= filteredHanjaData.length) currentIndex = 0;
            currentHanjaData = filteredHanjaData[currentIndex];
            if (!currentHanjaData) return;

            const studyCount = (learningStats.studyCount && learningStats.studyCount[currentHanjaData.no]) || 0;
            const studyCountBadge = `<div class="study-count-badge">학습${studyCount}회</div>`;
            
            if (currentMode === 'read') {
                correctBtn.classList.toggle('invisible', !isFlipped);
                incorrectBtn.classList.toggle('invisible', !isFlipped);
                cardFront.innerHTML = getCardFrontInfoBadgesHTML(currentHanjaData) + `<div class="flex-1 flex justify-center items-center hanja-font text-[10rem] font-bold">${currentHanjaData.hanja || ''}</div>` + studyCountBadge;
                cardBack.innerHTML = getBackCardContent(currentHanjaData);
            } else { // 'write' mode
                correctBtn.classList.add('invisible');
                incorrectBtn.classList.add('invisible');
                cardFront.innerHTML = getCardFrontInfoBadgesHTML(currentHanjaData, true) + `
                    <div id="start-write-area" class="flex flex-col justify-center items-center text-center h-full w-full cursor-pointer p-4">
                        <h3 class="text-lg font-bold text-accent-cyan mb-2">훈음 (뜻과소리)</h3>
                        <p class="text-5xl md:text-6xl font-semibold hanja-font mb-4 flex-grow flex items-center">${currentHanjaData.huneum || ''}</p>
                        <p class="text-sm text-gray-400 mt-2">여기를 터치하여 쓰기 연습 시작</p>
                    </div>` + studyCountBadge;
                cardBack.innerHTML = getWritePracticeContent(currentHanjaData);
            }
            
            setupCardClickableElements(cardFront);
            progressEl.textContent = `${currentIndex + 1} / ${filteredHanjaData.length}`;
            saveLastStateToFirestore();
        }
        
        function getCardFrontInfoBadgesHTML(data, isWriteMode = false) {
            if (!data) return '';
            const readModeBtn = isWriteMode 
                ? `<button class="btn-neumorphic !p-2 !text-xs" id="switch-to-read-btn">읽기모드</button>` 
                : `<div class="info-badge clickable type-link-btn" data-typeno="${data.typeNo || ''}">유형 ${data.typeNo || ''}</div>`;

            return `
                <div class="info-badge-container">
                    <div class="info-badge">${data.level || ''}</div>
                    ${readModeBtn}
                </div>
            `;
        }
        
        function parsePaja(pajaString) {
            if (!pajaString) return [];
            const components = [];
            const regex = /\(([^)]+)\)/g;
            let match;
            while ((match = regex.exec(pajaString)) !== null) {
                let component = match[1].split('=')[0].trim();
                if (component.length === 1) {
                    components.push(component);
                }
            }
            return components;
        }

        function getRelatedHanjaHTML(data) {
            if (!data) return '';
            const relatedContainer = new Map();

            const meaningRels = relatedMeaningData[data.hanja];
            if (meaningRels) {
                (meaningRels.synonyms || []).forEach(char => {
                    const hanjaObj = hanjaMap.get(char);
                    if (hanjaObj && !relatedContainer.has(char)) relatedContainer.set(char, { hanja: hanjaObj, reason: '유의' });
                });
                (meaningRels.antonyms || []).forEach(char => {
                    const hanjaObj = hanjaMap.get(char);
                    if (hanjaObj && !relatedContainer.has(char)) relatedContainer.set(char, { hanja: hanjaObj, reason: '반의' });
                });
            }

            const shapeRels = similarShapesData[data.hanja];
            if (shapeRels) {
                shapeRels.forEach(char => {
                    const hanjaObj = hanjaMap.get(char);
                    if (hanjaObj && !relatedContainer.has(char)) relatedContainer.set(char, { hanja: hanjaObj, reason: '유사' });
                });
            }

            if (relatedContainer.size === 0) return '';

            let relatedHanjaHTML = '';
            relatedContainer.forEach((value) => {
                const safeHanjaString = JSON.stringify(value.hanja).replace(/"/g, '&quot;');
                relatedHanjaHTML += `
                    <div class="small-card-container related-hanja-card" data-hanja="${safeHanjaString}">
                        <div class="small-card">
                            <div class="small-card-face small-card-front hanja-font">${value.hanja.hanja}</div>
                            <div class="small-card-face small-card-back hanja-font">
                                <div class="reason">${value.reason}</div>
                                <div class="hanja">${value.hanja.hanja}</div>
                            </div>
                        </div>
                    </div>`;
            });

            return `
                <div class="border-t border-gray-600"></div>
                <div class="flex-shrink-0">
                    <h3 class="text-xs font-bold text-text-main">관련 한자 (클릭: 네트워크탐색)</h3>
                    <div class="related-cards-grid mt-2">${relatedHanjaHTML}</div>
                </div>`;
        }

        async function callGeminiAPI(prompt) {
            const model = "gemini-2.5-flash-preview-05-20";
            const apiKey = "";
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;

            try {
                const payload = { contents: [{ parts: [{ text: prompt }] }] };
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) throw new Error(`API Error: ${response.status}`);
                
                const result = await response.json();
                
                if (result.candidates && result.candidates[0]?.content?.parts?.[0]?.text) {
                    return result.candidates[0].content.parts[0].text;
                }
                return "AI로부터 유효한 답변을 받지 못했습니다.";
            } catch (error) {
                console.error("AI API Error:", error);
                return `AI 호출에 실패했습니다: ${error.message}`;
            }
        }


        function getBackCardContent(data) {
            if (!data) return '';
            const naverLink = `https://hanja.naver.com/search?query=${encodeURIComponent(data.hanja || '')}`;
            const pajaComponents = parsePaja(data.paja);
            let pajaAnimationHTML = '';
            const relatedSectionHTML = getRelatedHanjaHTML(data);

            if (pajaComponents.length > 0) {
                const total = pajaComponents.length;
                const componentSpans = pajaComponents.map((comp, index) => `<span class="paja-component" style="transform: translateX(${(index - (total - 1) / 2) * 70}px);">${comp}</span>`).join('');
                const plusSpans = total > 1 ? pajaComponents.slice(0, -1).map((_, index) => `<span class="paja-plus" style="transform: translateX(${(index - (total - 2) / 2) * 70}px);">+</span>`).join('') : '';
                pajaAnimationHTML = `<div class="flex-shrink-0"><h3 class="text-accent-cyan">파자 보기</h3><div class="paja-animation-container">${componentSpans}${plusSpans}<span class="paja-final">${data.hanja}</span></div><button class="btn-neumorphic w-full py-2 text-xs paja-animate-btn">합체</button></div>`;
            }

            const externalLinksHTML = `<a href="${naverLink}" target="_blank" rel="noopener noreferrer" class="btn-neumorphic text-center flex items-center justify-center mt-2 py-2 text-base">사전 보기</a>`;

            return `<div class="w-full h-full flex flex-col text-left space-y-1 overflow-y-auto p-2 card-back-content">
                <div class="flex-shrink-0">
                    <p class="font-semibold hanja-font huneum-text -mt-2">${data.huneum || ''}</p>
                </div>
                <div class="border-t border-gray-600"></div>
                <div class="flex-shrink-0">
                    <h3>파자암기법</h3>
                    <p>${data.paja || ''}</p>
                </div>
                ${pajaAnimationHTML ? `<div class="border-t border-gray-600"></div>${pajaAnimationHTML}` : ''}
                ${relatedSectionHTML}
                <div class="border-t border-gray-600"></div>
                <div class="flex-shrink-0">
                    <h3>✨ AI 연상법</h3>
                    <div id="ai-mnemonic-output" class="mt-1 ai-output">버튼을 눌러 새로운 암기법을 확인해보세요.</div>
                    <div id="ai-mnemonic-loader" class="mt-2 text-center text-accent-cyan hidden"><p>AI가 생각 중입니다...</p></div>
                    <button class="btn-neumorphic w-full mt-2 py-2 text-xs ai-mnemonic-btn">✨ 새 연상법</button>
                </div>
                <div class="border-t border-gray-600"></div>
                <div class="flex-shrink-0">
                    <h3>노트</h3>
                    <p>${data.note || ''}</p>
                </div>
                <div class="border-t border-gray-600"></div>
                ${externalLinksHTML}
            </div>`;
        }
        
        function getWritePracticeContent(data) {
            return `
            <div class="w-full h-full flex flex-col p-1">
                <div class="flex-1 min-h-0 relative aspect-square w-full mx-auto mb-2">
                    <canvas id="write-canvas" class="w-full h-full"></canvas>
                    <canvas id="stroke-guide-canvas" class="w-full h-full"></canvas>
                    <div id="write-answer-display" class="absolute inset-0 flex justify-center items-center bg-black bg-opacity-70 rounded-lg text-accent-cyan hanja-font text-8xl md:text-9xl hidden cursor-pointer"></div>
                </div>
                <div id="write-controls" class="flex-shrink-0">
                    <div id="write-initial-controls" class="grid grid-cols-4 gap-2">
                        <button id="home-btn-write" class="btn-neumorphic py-2 text-xs">❮ 이전</button>
                        <button id="clear-canvas-btn" class="btn-neumorphic py-2 text-xs">삭제</button>
                        <button id="show-answer-btn" class="btn-neumorphic py-2 text-xs">확인</button>
                        <button id="stroke-order-btn" class="btn-neumorphic py-2 text-xs">✍️</button>
                    </div>
                    <div id="write-check-buttons" class="hidden grid grid-cols-2 gap-2">
                        <button id="write-correct-btn" class="btn-neumorphic check-btn correct py-3 text-xs">✅ 암기</button>
                        <button id="write-incorrect-btn" class="btn-neumorphic check-btn incorrect py-3 text-xs">❌ 미암기</button>
                    </div>
                </div>
            </div>`;
        }

        function filterCards(level, preserveIndex = false) {
            currentLevel = level;
            document.querySelectorAll('.control-panel #level-selector button').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`.control-panel #level-selector button[data-level="${level}"]`)?.classList.add('active');

            if (level === '오답') {
                filteredHanjaData = hanjaData.filter(item => incorrectAnswers.has(item.no));
            } else if (level === '암기') {
                filteredHanjaData = hanjaData.filter(item => knownAnswers.has(item.no));
            } else if (level === '미암기') {
                filteredHanjaData = hanjaData.filter(item => !knownAnswers.has(item.no));
            } else if (level === '전체') {
                filteredHanjaData = [...hanjaData];
            } else {
                filteredHanjaData = hanjaData.filter(item => item.level === level);
            }
            if (!preserveIndex) {
                currentIndex = 0;
            } else {
                if (currentIndex >= filteredHanjaData.length) {
                    currentIndex = Math.max(0, filteredHanjaData.length - 1);
                }
            }
            resetCardView(updateCard);
        }
        
        function resetCardView(callback) {
            if (isFlipped) {
                card.classList.remove('is-flipped');
                isFlipped = false;
                setTimeout(callback, 300);
            } else {
                callback();
            }
        }

        function navigateCard(direction) {
            if (filteredHanjaData.length === 0) return;
            currentIndex = (currentIndex + direction + filteredHanjaData.length) % filteredHanjaData.length;
            const hanjaToTrack = filteredHanjaData[currentIndex];
            if(hanjaToTrack) trackStudyEvent(hanjaToTrack.no);
            resetCardView(updateCard);
        }

        function markAnswer(isCorrect, fromWriteMode = false) {
            if (!currentHanjaData) return;
            const hanjaNo = currentHanjaData.no;
            
            if (isCorrect) {
                knownAnswers.add(hanjaNo);
                incorrectAnswers.delete(hanjaNo);
            } else {
                knownAnswers.delete(hanjaNo);
                incorrectAnswers.add(hanjaNo);
            }
            
            trackStudyEvent(hanjaNo);
            
            if ((currentLevel === '오답' && isCorrect) || (currentLevel === '미암기' && isCorrect) || (currentLevel === '암기' && !isCorrect)) {
                filterCards(currentLevel, true);
            } else {
                navigateCard(1);
            }
        }

        function showView(viewId) {
            networkTooltip.classList.remove('visible');
            networkState.lastClickedHanja = null;
            const views = [authView, mainView, speedQuizView, typeLearningView, detailView, networkView, newsLinkView, wordbookView, document.getElementById('wordbook-detail-view'), studyView];
            views.forEach(view => {
                if(view) view.classList.toggle('hidden-view', view.id !== viewId);
            });
        }
        
        function showModal(message, title = null, buttons = [{ text: '확인', id: 'custom-modal-close' }]) {
            const modalMessage = document.getElementById('custom-modal-message');
            const modalButtons = document.getElementById('modal-buttons');
            
            let contentHTML = '';
            if (title) {
                contentHTML += `<h2 class="text-2xl font-bold text-accent-cyan mb-4">${title}</h2>`;
            }
            contentHTML += `<div class="max-h-[60vh] overflow-y-auto text-text-light text-base text-left">${message}</div>`;
            modalMessage.innerHTML = contentHTML;

            modalButtons.innerHTML = '';
            buttons.forEach(btnInfo => {
                const button = document.createElement('button');
                button.id = btnInfo.id;
                button.textContent = btnInfo.text;
                button.className = 'btn-neumorphic w-full py-3';
                if (btnInfo.isPrimary) {
                    button.classList.add('bg-accent-cyan', 'text-bg-dark');
                }
                button.onclick = () => {
                    document.getElementById('custom-modal-overlay').classList.add('hidden');
                    if (btnInfo.onClick) {
                        btnInfo.onClick();
                    }
                };
                modalButtons.appendChild(button);
            });
            
            document.getElementById('custom-modal-overlay').classList.remove('hidden');
        }
        
        function returnToPreviousState() {
            if (previousState) {
                const prev = previousState;
                previousState = null;
                
                if (prev.view === 'network') {
                    showNetworkView(prev.centerHanja);
                } else if (prev.view === 'wordbook-detail-view') {
                    showWordbookDetailView(prev.wordData);
                } else {
                    showView(prev.view);
                    if (prev.view === 'type-learning-view') {
                        setTimeout(() => { window.scrollTo(0, typeViewScrollPos); }, 0);
                    } else if (prev.view === 'network-view') {
                        setTimeout(() => { window.scrollTo(0, networkViewScrollPos); }, 0);
                    }
                }
            } else {
                goHome();
            }
        }

        function goHome() {
            showView('main-view');
            window.scrollTo(0, 0);

            let modeToRestore = 'read';
            let levelToRestore = currentLevel;
            let hanjaNoToRestore = null;

            if (mainLearningState) {
                modeToRestore = mainLearningState.mode;
                levelToRestore = mainLearningState.level;
                const lastHanja = mainLearningState.data[mainLearningState.index];
                if (lastHanja) {
                    hanjaNoToRestore = lastHanja.no;
                }
            }

            currentMode = modeToRestore;
            document.querySelectorAll('.control-panel #mode-selector button').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.mode === currentMode);
            });
            
            filterCards(levelToRestore, true); 
            let resumeIndex = hanjaNoToRestore ? filteredHanjaData.findIndex(h => h.no === hanjaNoToRestore) : -1;

            if (resumeIndex === -1 && hanjaNoToRestore) {
                levelToRestore = '전체';
                filterCards(levelToRestore, true);
                resumeIndex = filteredHanjaData.findIndex(h => h.no === hanjaNoToRestore);
            }

            currentIndex = (resumeIndex !== -1) ? resumeIndex : 0;
            
            resetCardView(updateCard);
        }

        function initializeAppUI() {
            authView.classList.add('hidden-view');
            mainView.classList.remove('hidden-view');
            sessionStartTime = Date.now();

            if (lastStateFromCloud && lastStateFromCloud.level) {
                currentMode = lastStateFromCloud.mode || 'read';
                let levelToRestore = lastStateFromCloud.level;
                
                document.querySelectorAll('.control-panel #mode-selector button').forEach(btn => btn.classList.toggle('active', btn.dataset.mode === currentMode));
                
                _applyFilter(levelToRestore);
                let resumeIndex = lastStateFromCloud.hanjaNo ? filteredHanjaData.findIndex(h => h.no === lastStateFromCloud.hanjaNo) : -1;
                
                if (resumeIndex === -1 && lastStateFromCloud.hanjaNo) {
                    levelToRestore = '전체';
                    _applyFilter(levelToRestore);
                    resumeIndex = filteredHanjaData.findIndex(h => h.no === lastStateFromCloud.hanjaNo);
                }
                
                currentLevel = levelToRestore;
                document.querySelectorAll('.control-panel #level-selector button').forEach(btn => btn.classList.toggle('active', btn.dataset.level === currentLevel));

                currentIndex = resumeIndex !== -1 ? resumeIndex : 0;
                updateCard();
            } else {
                filterCards('전체');
            }
        }
        
        function _applyFilter(level) {
            if (level === '오답') {
                filteredHanjaData = hanjaData.filter(item => incorrectAnswers.has(item.no));
            } else if (level === '암기') {
                filteredHanjaData = hanjaData.filter(item => knownAnswers.has(item.no));
            } else if (level === '미암기') {
                filteredHanjaData = hanjaData.filter(item => !knownAnswers.has(item.no));
            } else if (level === '전체') {
                filteredHanjaData = [...hanjaData];
            } else {
                filteredHanjaData = hanjaData.filter(item => item.level === level);
            }
        }
        
        function setupCardClickableElements(container) {
            const typeLinkBtn = container.querySelector('.type-link-btn');
            if (typeLinkBtn) {
                typeLinkBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const typeNo = parseInt(e.currentTarget.dataset.typeno, 10);
                    navigateToTypeView(typeNo);
                });
            }

            const switchToReadBtn = container.querySelector('#switch-to-read-btn');
            if(switchToReadBtn) {
                switchToReadBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    currentMode = 'read';
                    document.querySelectorAll('.control-panel #mode-selector button').forEach(btn => btn.classList.toggle('active', btn.dataset.mode === 'read'));
                    resetCardView(updateCard);
                });
            }
        }
        
        function navigateToTypeView(typeNo) {
            if (!typeNo) return;
            previousState = { 
                mode: currentMode, 
                level: currentLevel, 
                index: currentIndex, 
                data: [...filteredHanjaData] 
            };
            
            currentMode = 'type';
            document.querySelectorAll('.control-panel #mode-selector button').forEach(btn => btn.classList.toggle('active', btn.dataset.mode === 'type'));
            
            const page = Math.floor((typeNo - 1) / 20);
            currentTypePage = page;
            showTypeLearningView();

            setTimeout(() => {
                const targetElement = document.getElementById(`type-group-${typeNo}`);
                if (targetElement) {
                    targetElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }, 100);
        }
        
        function showTypeLearningView() {
            showView('type-learning-view');
            renderTypeView();
        }

        function renderTypeView() {
            const container = typeLearningView;
            container.innerHTML = `<div id="type-view-content" class="w-full max-w-4xl mx-auto"></div>`;
            const content = container.querySelector('#type-view-content');

            const groupedData = hanjaData.reduce((acc, curr) => {
                if (curr && curr.typeNo) {
                    if (!acc[curr.typeNo]) acc[curr.typeNo] = [];
                    acc[curr.typeNo].push(curr);
                }
                return acc;
            }, {});
            const uniqueTypeKeys = Object.keys(groupedData).sort((a,b) => parseInt(a) - parseInt(b));
            
            let paginationHTML = '';
            const totalPages = 20;
            for (let i = 0; i < totalPages; i++) {
                const start = i * 20 + 1;
                const end = (i + 1) * 20;
                paginationHTML += `<button data-page="${i}" class="${i === currentTypePage ? 'active' : ''}">${start}-${end}</button>`;
            }

            content.innerHTML = `
                <div class="flex justify-between items-center mb-6">
                    <h1 class="text-3xl font-bold text-text-main">유형별 학습</h1>
                    <button id="home-btn-type" class="btn-neumorphic py-3 px-5">학습 복귀</button>
                </div>
                <div class="control-panel mb-6">
                    <div id="type-pagination-bar" class="flex overflow-x-auto">${paginationHTML}</div>
                </div>
                <div id="type-groups-wrapper" class="space-y-8"></div>
            `;
            
            const wrapper = content.querySelector('#type-groups-wrapper');
            const pageStartTypeNo = currentTypePage * 20 + 1;
            const pageEndTypeNo = (currentTypePage + 1) * 20;
            const keysForPage = uniqueTypeKeys.filter(key => parseInt(key) >= pageStartTypeNo && parseInt(key) <= pageEndTypeNo);

            for (const typeNo of keysForPage) {
                const group = groupedData[typeNo];
                const representative = group[0];
                const related = group.slice(1);
                const groupEl = document.createElement('div');
                groupEl.className = 'type-group-container bg-bg-light p-4 rounded-xl shadow-lg';
                groupEl.id = `type-group-${typeNo}`;
                let relatedHTML = related.map(hanja => {
                    const safeHanjaString = JSON.stringify(hanja).replace(/"/g, '&quot;');
                    return `
                    <div class="small-card-container" data-hanja="${safeHanjaString}">
                        <div class="small-card">
                            <div class="small-card-face small-card-front hanja-font">${hanja.hanja}</div>
                            <div class="small-card-face small-card-back hanja-font" style="font-size: 1.2rem; line-height: 1.2; padding: 4px; display: flex; align-items: center; justify-content: center;">${hanja.huneum}</div>
                        </div>
                    </div>`;
                }).join('');

                const safeRepString = JSON.stringify(representative).replace(/"/g, '&quot;');
                groupEl.innerHTML = `<div class="flex flex-col md:flex-row items-center gap-4">
                    <div class="flex flex-col items-center gap-2">
                        <div class="representative-card hanja-font" data-hanja="${safeRepString}">${representative.hanja}</div>
                        <div class="btn-neumorphic text-xs py-1 px-3">유형 ${typeNo}</div>
                    </div>
                    <div class="flex-1 w-full">
                        <div class="flex justify-between items-start mb-2">
                            <div>
                                <p class="text-accent-cyan font-bold">${representative.huneum}</p>
                                <p class="text-sm text-text-light mt-2">${representative.paja}</p>
                            </div>
                            <button class="btn-neumorphic return-to-study-btn py-2 px-3 text-sm flex-shrink-0">학습 복귀</button>
                        </div>
                        <div class="related-cards-grid mt-4">${relatedHTML}</div>
                        <div class="mt-4 border-t border-gray-600 pt-4">
                            <div id="ai-story-output-${typeNo}" class="ai-output mb-2">버튼을 눌러 이 한자들이 포함된 AI 이야기를 확인해보세요.</div>
                            <div id="ai-story-loader-${typeNo}" class="text-center text-accent-cyan hidden mb-2"><p>AI가 이야기를 만들고 있습니다...</p></div>
                            <button class="btn-neumorphic w-full py-2 text-sm ai-story-btn">✨ AI 이야기</button>
                        </div>
                    </div>
                </div>`;
                wrapper.appendChild(groupEl);
            }
            content.querySelector('#home-btn-type').addEventListener('click', goHome);
            content.querySelector('#type-pagination-bar').addEventListener('click', (e) => {
                const button = e.target.closest('button[data-page]');
                if (button) {
                    currentTypePage = parseInt(button.dataset.page, 10);
                    renderTypeView();
                }
            });
        }

        function showWordbookDetailView(wordData) {
            previousState = { view: 'wordbook-view' };

            const wordbookDetailView = document.getElementById('wordbook-detail-view');
            const characters = wordData.hanja.split('');
            const naverLink = `https://hanja.naver.com/search?query=${encodeURIComponent(wordData.hanja)}`;

            let characterCardsHTML = characters.map(char => {
                const charData = hanjaMap.get(char);
                if (!charData) return ''; // Skip if character data not found
                
                const safeCharDataString = JSON.stringify(charData).replace(/"/g, '&quot;');
                return `
                    <div class="small-card-container individual-hanja-card" data-hanja="${safeCharDataString}">
                        <div class="small-card">
                            <div class="small-card-face small-card-front hanja-font">${char}</div>
                            <div class="small-card-face small-card-back hanja-font" style="font-size: 1.4rem; line-height: 1.1; padding: 4px; display: flex; align-items: center; justify-content: center;">
                                ${charData.huneum}
                            </div>
                        </div>
                    </div>
                `;
            }).join('');

            wordbookDetailView.innerHTML = `
                <div class="w-full max-w-2xl mx-auto flex flex-col h-screen p-4">
                     <div class="flex justify-between items-center mb-4 flex-shrink-0">
                        <div class="text-left">
                             <h1 class="text-5xl font-bold text-text-main hanja-font">${wordData.hanja}</h1>
                             <p class="text-2xl text-accent-cyan mt-2">${wordData.hangul}</p>
                        </div>
                        <div class="flex items-center gap-2">
                             <a href="${naverLink}" target="_blank" rel="noopener noreferrer" class="btn-neumorphic p-3" title="네이버 한자사전">
                                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg>
                             </a>
                             <button id="wordbook-detail-back-btn" class="btn-neumorphic p-3 text-xl" title="단어장으로 복귀">📔</button>
                        </div>
                    </div>

                    <div class="related-cards-grid flex-grow overflow-y-auto pb-8">
                        ${characterCardsHTML}
                    </div>
                </div>
            `;

            showView('wordbook-detail-view');

            wordbookDetailView.querySelector('#wordbook-detail-back-btn').addEventListener('click', () => {
                renderWordbook(); // Rerender in case of changes
                showView('wordbook-view');
            });

            wordbookDetailView.querySelectorAll('.small-card-container.individual-hanja-card').forEach(cardContainer => {
                cardContainer.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const card = cardContainer.querySelector('.small-card');
                    
                    if (card.classList.contains('is-flipped')) {
                        try {
                            const hanjaObject = JSON.parse(cardContainer.dataset.hanja);
                            // Pass the original wordData as context so we can return to this view
                            showDetailView(hanjaObject, 'wordbook-detail-view', wordData);
                        } catch(err) {
                            console.error("Failed to parse hanja data from wordbook detail card:", cardContainer.dataset.hanja, err);
                        }
                    } else {
                        card.classList.toggle('is-flipped');
                    }
                });
            });
        }


        function showDetailView(hanja, fromView, contextData = null) {
            previousView = fromView;
             // This is the key change: store the context needed to return
            if (fromView === 'wordbook-detail-view') {
                previousState = { view: fromView, wordData: contextData };
            } else {
                 previousState = { view: fromView }; // Old behavior for other views
            }
            currentHanjaData = hanja; 
            
            let backButtonText = '← 뒤로';
            if (fromView === 'type-learning-view') {
                backButtonText = '← 유형';
            } else if (fromView === 'network-view') {
                backButtonText = '← 네트워크';
            } else if (fromView === 'main-view') {
                backButtonText = '← 학습';
            } else if (fromView === 'wordbook-detail-view') {
                backButtonText = '← 단어';
            }
            
            detailView.innerHTML = `
                <div class="w-full max-w-md md:max-w-lg mx-auto h-screen flex flex-col p-4">
                    <div class="flex-shrink-0 mb-4">
                        <button id="detail-view-back-btn" class="btn-neumorphic py-3 px-5">${backButtonText}</button>
                    </div>
                    <div class="flex-1 card-container w-full">
                        <div id="detail-card-content" class="card-face overflow-y-auto">
                            ${getBackCardContent(hanja)}
                        </div>
                    </div>
                </div>
            `;

            const detailContent = detailView.querySelector('#detail-card-content');
            setupCardClickableElements(detailContent);
            
            detailView.querySelector('#detail-view-back-btn').addEventListener('click', () => {
                returnToPreviousState();
            });

            showView('detail-view');
            window.scrollTo(0, 0);
        }
        
        function initializeWriteCanvas(canvasId) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            
            const isQuizCanvas = canvasId === 'writing-quiz-canvas';
            const guideCanvas = isQuizCanvas ? null : document.getElementById('stroke-guide-canvas');

            const ctx = canvas.getContext('2d');
            
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();

            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            if (guideCanvas) {
                guideCanvas.width = rect.width * dpr;
                guideCanvas.height = rect.height * dpr;
            }

            ctx.scale(dpr, dpr);
            
            ctx.lineWidth = 7; // Increased from 5 to 7 for better touch feel
            ctx.strokeStyle = '#111';
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            if(!isQuizCanvas) {
                const strokeOrderBtn = document.getElementById('stroke-order-btn');
                if(strokeOrderBtn) strokeOrderBtn.style.display = (strokeData && strokeData[currentHanjaData.hanja]) ? 'inline-block' : 'none';
            }
        }

        function startQuiz() {
            showView('speed-quiz-view');
            document.getElementById('quiz-mode-panel').classList.remove('hidden');
            document.getElementById('quiz-type-selection-panel').classList.add('hidden');
            document.getElementById('quiz-setup-panel').classList.add('hidden');
            document.getElementById('quiz-main-panel').classList.add('hidden');
            document.getElementById('quiz-end-panel').classList.add('hidden');
            document.getElementById('writing-quiz-panel').classList.add('hidden');
        }
        
        // --- Writing Quiz ---
        function startWritingQuiz() {
            if (userWordbook.size === 0) {
                showModal("단어장에 단어가 없습니다. 뉴스 분석 기능을 통해 단어를 추가해주세요.", "쓰기 퀴즈 불가");
                return;
            }
            
            currentQuizType = 'writing';
            writingQuizData = Array.from(userWordbook.keys()).sort(() => 0.5 - Math.random());
            currentWritingQuizIndex = 0;
            
            document.getElementById('quiz-mode-panel').classList.add('hidden');
            document.getElementById('writing-quiz-panel').classList.remove('hidden');
            
            loadNextWritingQuizQuestion();
        }
        
        function loadNextWritingQuizQuestion() {
            const writingQuizPanel = document.getElementById('writing-quiz-panel');
            if (currentWritingQuizIndex >= writingQuizData.length) {
                showModal("단어장의 모든 단어 쓰기 연습을 완료했습니다!", "쓰기 퀴즈 완료!", [
                    { text: '다시하기', onClick: startWritingQuiz },
                    { text: '홈으로', isPrimary: true, onClick: goHome }
                ]);
                return;
            }
            
            document.getElementById('writing-quiz-progress').textContent = `${currentWritingQuizIndex + 1} / ${writingQuizData.length}`;
            const hanjaWord = writingQuizData[currentWritingQuizIndex];
            const hangulWord = userWordbook.get(hanjaWord) || getHangulWord(hanjaWord); // Use cached or fallback
            document.getElementById('writing-quiz-question').textContent = hangulWord;

            const canvas = document.getElementById('writing-quiz-canvas');
            const ctx = canvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;
            ctx.clearRect(0, 0, canvas.width / dpr, canvas.height / dpr);

            document.getElementById('writing-quiz-answer-display').textContent = '';
            
            // Reset button states
            document.getElementById('check-writing-quiz-answer-btn').classList.remove('hidden');
            document.getElementById('writing-quiz-mark-btns').classList.add('hidden');
            
            initializeWriteCanvas('writing-quiz-canvas');
        }

        // --- Multiple Choice Quiz ---
        function initializeQuiz(count, shouldShuffle = true) {
            currentQuizType = 'multiple-choice';
            if (quizSourceData.length < 4) {
                showModal('퀴즈를 만들기에 한자가 부족합니다. (최소 4개 이상 필요)');
                startQuiz();
                return;
            }
            
            let actualQuizCount = count;
            if (quizSourceData.length < count) {
                actualQuizCount = quizSourceData.length;
                showModal(`선택한 문제 수(${count}개)보다 한자가 부족하여, 현재 있는${actualQuizCount}개의 한자로만 퀴즈를 시작합니다.`);
            }

            document.getElementById('quiz-setup-panel').classList.add('hidden');
            document.getElementById('quiz-main-panel').classList.remove('hidden');
            
            let tempQuizData = [...quizSourceData];
            if(shouldShuffle) {
                tempQuizData.sort(() => 0.5 - Math.random());
            }
            quizData = tempQuizData.slice(0, actualQuizCount);

            currentQuizIndex = 0;
            quizScore = 0;
            loadNextQuizQuestion();
        }

        function loadNextQuizQuestion() {
            if (currentQuizIndex >= quizData.length) {
                endQuiz();
                return;
            }
            document.getElementById('quiz-progress').textContent = `${currentQuizIndex + 1} / ${quizData.length}`;
            const question = quizData[currentQuizIndex];
            document.getElementById('quiz-hanja').textContent = question.hanja;
            let options = [question];
            while (options.length < 4) {
                const randomHanja = hanjaData[Math.floor(Math.random() * hanjaData.length)];
                if (randomHanja && !options.some(opt => opt.no === randomHanja.no)) {
                    options.push(randomHanja);
                }
            }
            options.sort(() => 0.5 - Math.random());
            const quizOptions = document.getElementById('quiz-options');
            quizOptions.innerHTML = '';
            options.forEach(opt => {
                const button = document.createElement('button');
                button.className = 'btn-neumorphic quiz-option-btn hanja-font py-4 text-lg';
                button.textContent = opt.huneum;
                button.onclick = (e) => selectQuizAnswer(e.target, opt.no === question.no, question.no);
                quizOptions.appendChild(button);
            });
            startTimer();
        }

        function startTimer() {
            clearInterval(timerInterval);
            const timerBar = document.getElementById('timer-bar');
            timerBar.style.transition = 'none';
            timerBar.style.transform = 'scaleX(1)';
            setTimeout(() => {
                timerBar.style.transition = `transform ${QUIZ_TIME}s linear`;
                timerBar.style.transform = 'scaleX(0)';
            }, 50);
            timerInterval = setTimeout(() => {
                selectQuizAnswer(null, false, quizData[currentQuizIndex].no);
            }, QUIZ_TIME * 1000);
        }

        function selectQuizAnswer(selectedButton, isCorrect, questionId) {
            clearInterval(timerInterval);
            const quizOptions = document.getElementById('quiz-options');
            const buttons = quizOptions.querySelectorAll('button');
            buttons.forEach(btn => btn.disabled = true);
            const correctButton = Array.from(buttons).find(btn => btn.textContent === quizData[currentQuizIndex].huneum);
            if(correctButton) {
                correctButton.style.background = 'var(--correct)';
            }
            if (isCorrect) {
                quizScore++;
                knownAnswers.add(questionId);
                incorrectAnswers.delete(questionId);
            } else {
                if (selectedButton) selectedButton.style.background = 'var(--incorrect)';
                knownAnswers.delete(questionId);
                incorrectAnswers.add(questionId);
            }
            saveDataToFirestore();
            setTimeout(() => {
                currentQuizIndex++;
                loadNextQuizQuestion();
            }, 800);
        }

        function endQuiz() {
            document.getElementById('quiz-main-panel').classList.add('hidden');
            document.getElementById('quiz-end-panel').classList.remove('hidden');
            const accuracy = quizData.length > 0 ? Math.round((quizScore / quizData.length) * 100) : 0;
            document.getElementById('quiz-final-score').textContent = `최종 점수: ${quizScore} / ${quizData.length}`;
            document.getElementById('quiz-accuracy').textContent = `정답률: ${accuracy}%`;
        }
        
        function animateStrokeOrder(character) {
            const strokes = strokeData[character];
            if (!strokes) return;

            const guideCanvas = document.getElementById('stroke-guide-canvas');
            if(!guideCanvas) return;
            const ctx = guideCanvas.getContext('2d');
            const rect = guideCanvas.getBoundingClientRect();
            const size = rect.width;
            
            ctx.clearRect(0, 0, guideCanvas.width, guideCanvas.height);
            ctx.setTransform(1, 0, 0, 1, 0, 0); 
            
            const dpr = window.devicePixelRatio || 1;
            ctx.scale(dpr, dpr);
            
            ctx.lineWidth = 8;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            const scale = size / 1024;
            ctx.scale(scale, scale);

            let strokeIndex = 0;

            function drawNextStroke() {
                if (strokeIndex >= strokes.length) {
                    setTimeout(() => {}, 1000);
                    return;
                }
                
                ctx.strokeStyle = `hsl(${strokeIndex * 20}, 70%, 60%)`;
                const path = new Path2D(strokes[strokeIndex]);
                ctx.stroke(path);
                
                strokeIndex++;
                setTimeout(drawNextStroke, 200);
            }
            drawNextStroke();
        }

        function setupNetworkViewListeners() {
            document.getElementById('home-btn-network').addEventListener('click', goHome);
        }

        function showNetworkView(centerOnHanjaChar = null) {
            previousState = { view: 'network', centerHanja: centerOnHanjaChar };
            showView('network-view');
            const targetHanja = centerOnHanjaChar || hanjaData[0]?.hanja;
            if (targetHanja) {
                renderHanjaNetwork(targetHanja);
            } else {
                document.getElementById('hanja-network-graph').innerHTML = `<p class="text-center text-text-light">표시할 한자가 없습니다.</p>`;
            }
        }

        function renderHanjaNetwork(centerHanjaChar) {
            networkState.currentCenter = centerHanjaChar;
            const graphContainer = document.getElementById('hanja-network-graph');
            graphContainer.innerHTML = ''; 

            const centerNode = hanjaData.find(h => h.hanja === centerHanjaChar);
            if (!centerNode) return;

            const relatedNodes = new Map();
            const MAX_NODES = 12;

            const addNode = (hanjaObj, reason) => {
                if (relatedNodes.size >= MAX_NODES) return;
                if (hanjaObj && hanjaObj.hanja !== centerNode.hanja && !relatedNodes.has(hanjaObj.hanja)) {
                    relatedNodes.set(hanjaObj.hanja, { node: hanjaObj, reason });
                }
            };

            hanjaData.filter(h => h.typeNo === centerNode.typeNo).forEach(h => addNode(h, '유형'));
            if (relatedNodes.size < MAX_NODES) {
                const meaningData = relatedMeaningData[centerNode.hanja];
                if (meaningData) {
                    (meaningData.synonyms || []).forEach(char => addNode(hanjaMap.get(char), '유의'));
                    (meaningData.antonyms || []).forEach(char => addNode(hanjaMap.get(char), '반의'));
                }
            }
            if (relatedNodes.size < MAX_NODES) {
                const similarChars = similarShapesData[centerNode.hanja] || [];
                similarChars.forEach(char => addNode(hanjaMap.get(char), '유사'));
            }
            
            const nodes = Array.from(relatedNodes.values()).slice(0, MAX_NODES);
            const svgNS = "http://www.w3.org/2000/svg";
            const svg = document.createElementNS(svgNS, "svg");
            svg.setAttribute('width', '100%');
            svg.setAttribute('height', '100%');
            svg.setAttribute('viewBox', '0 0 500 500');
            graphContainer.appendChild(svg);

            svg.addEventListener('click', (e) => {
                if (e.target === svg) {
                    networkTooltip.classList.remove('visible');
                    networkState.lastClickedHanja = null;
                }
            });

            const centerX = 250, centerY = 250, radius = 180;
            const renderedNodeInfo = [];

            nodes.forEach((item, i) => {
                const angle = (i / nodes.length) * 2 * Math.PI - (Math.PI / 2);
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                
                const line = document.createElementNS(svgNS, 'line');
                line.setAttribute('x1', centerX); line.setAttribute('y1', centerY);
                line.setAttribute('x2', x); line.setAttribute('y2', y);
                line.setAttribute('stroke', 'var(--bg-light)'); line.setAttribute('stroke-width', '2');
                svg.appendChild(line);
                renderedNodeInfo.push({x, y, typeNo: item.node.typeNo});
            });

            const groupsByType = renderedNodeInfo.reduce((acc, node) => {
                if(node.typeNo) {
                    if (!acc[node.typeNo]) acc[node.typeNo] = [];
                    acc[node.typeNo].push({x: node.x, y: node.y});
                }
                return acc;
            }, {});

            Object.values(groupsByType).forEach(group => {
                if (group.length < 2) return;
                const centroid = group.reduce((acc, p) => ({x: acc.x + p.x, y: acc.y + p.y}), {x: 0, y: 0});
                centroid.x /= group.length; centroid.y /= group.length;
                let maxDistSq = 0;
                group.forEach(p => {
                    const distSq = (p.x - centroid.x)**2 + (p.y - centroid.y)**2;
                    if (distSq > maxDistSq) maxDistSq = distSq;
                });
                const groupRadius = Math.sqrt(maxDistSq) + 40; 
                const groupCircle = document.createElementNS(svgNS, 'circle');
                groupCircle.setAttribute('cx', centroid.x); groupCircle.setAttribute('cy', centroid.y);
                groupCircle.setAttribute('r', groupRadius);
                groupCircle.setAttribute('fill', 'rgba(129, 230, 217, 0.05)');
                groupCircle.setAttribute('stroke', 'rgba(129, 230, 217, 0.3)');
                groupCircle.setAttribute('stroke-width', '2'); groupCircle.setAttribute('stroke-dasharray', '5 5');
                svg.appendChild(groupCircle);
            });

            nodes.forEach((item, i) => {
                const angle = (i / nodes.length) * 2 * Math.PI - (Math.PI / 2);
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                svg.appendChild(createNode(item.node, x, y, false));
            });
            
            svg.appendChild(createNode(centerNode, centerX, centerY, true));
        }

        function navigateToCardFromNetwork(hanjaObject) {
            previousState = { view: 'network', centerHanja: networkState.currentCenter };
            
            showView('main-view');
            filterCards(hanjaObject.level, true);
            
            const newIndex = filteredHanjaData.findIndex(h => h.no === hanjaObject.no);
            if (newIndex !== -1) {
                currentIndex = newIndex;
                updateCard();
            }
        }

        function createNode(hanja, x, y, isCenter = false) {
            const svgNS = "http://www.w3.org/2000/svg";
            const group = document.createElementNS(svgNS, 'g');
            group.setAttribute('transform', `translate(${x}, ${y})`);
            group.classList.add('network-node');

            const circleRadius = isCenter ? 50 : 40;
            const circle = document.createElementNS(svgNS, 'circle');
            circle.setAttribute('r', circleRadius);
            circle.setAttribute('fill', isCenter ? 'var(--bg-med)' : 'var(--bg-light)');
            circle.setAttribute('stroke', 'var(--accent-cyan)'); circle.setAttribute('stroke-width', '3');
            group.appendChild(circle);

            const textHanja = document.createElementNS(svgNS, 'text');
            textHanja.setAttribute('class', 'node-face node-front');
            textHanja.style.fontSize = isCenter ? '3.2rem' : '2.5rem';
            textHanja.textContent = hanja.hanja;
            group.appendChild(textHanja);
            
            const textType = document.createElementNS(svgNS, 'text');
            textType.setAttribute('text-anchor', 'middle'); textType.setAttribute('y', circleRadius + 15);
            textType.setAttribute('fill', 'var(--text-light)'); textType.style.fontSize = '0.8rem';
            textType.textContent = `유형 ${hanja.typeNo}`;
            group.appendChild(textType);

            group.addEventListener('click', (e) => {
                e.stopPropagation();
                if (networkState.lastClickedHanja === hanja.hanja) {
                    navigateToCardFromNetwork(hanja);
                    networkTooltip.classList.remove('visible');
                    networkState.lastClickedHanja = null;
                } else {
                    networkState.lastClickedHanja = hanja.hanja;
                    const ctm = e.currentTarget.getScreenCTM();
                    const svgRect = e.currentTarget.ownerSVGElement.getBoundingClientRect();
                    const scale = svgRect.width / 500;
                    
                    const tooltipX = ctm.e + (circleRadius * scale / 2);
                    const tooltipY = ctm.f - (circleRadius * scale / 2);

                    networkTooltip.textContent = hanja.huneum;
                    networkTooltip.style.left = `${tooltipX}px`; networkTooltip.style.top = `${tooltipY}px`;
                    networkTooltip.classList.add('visible');
                }
            });
            return group;
        }
        
        function getHangulFromHuneum(huneum) {
            if (!huneum) return '';
            // Get the primary reading (before any '/')
            let primaryReading = huneum.split('/')[0];
            // Replace colons, trim, and then split by space
            const parts = primaryReading.replace(/:/g, ' ').trim().split(/\s+/);
            // The last part should be the sound
            return parts[parts.length - 1];
        }

        function getHangulWord(hanjaWord) {
            // This is a fallback. The primary source should be the AI-generated pronunciation.
            return hanjaWord.split('').map(char => {
                const data = hanjaMap.get(char);
                return data ? getHangulFromHuneum(data.huneum) : '?';
            }).join('');
        }
        
        async function renderWordbook() {
            const sortedWords = Array.from(userWordbook.keys()).sort((a, b) => a.localeCompare(b, 'ko'));

            let contentHTML = `
                <div class="w-full max-w-2xl mx-auto flex flex-col h-screen">
                    <div class="flex justify-between items-center mb-4 flex-shrink-0">
                        <h1 class="text-3xl font-bold text-text-main">단어장</h1>
                        <div class="flex items-center gap-2">
                            <button id="toggle-wordbook-view-btn" class="btn-neumorphic py-3 px-4 text-sm">${wordbookDisplayMode === 'hanja' ? '한글' : '한자'}</button>
                            <button id="home-btn-wordbook" class="btn-neumorphic py-3 px-5">🏠</button>
                        </div>
                    </div>
                    <div id="wordbook-list" class="flex-grow overflow-y-auto pb-8">`;

            if (sortedWords.length === 0) {
                contentHTML = contentHTML.replace('grid', 'block'); // Switch to block for single message
                contentHTML += '<p class="text-center text-gray-400 mt-8">단어장에 추가된 단어가 없습니다.<br>뉴스 분석 코너에서 단어를 추가해보세요.</p>';
            } else {
                for (const word of sortedWords) {
                    const characters = word.split('');
                    const huneumDetails = characters.map(char => {
                        const hanjaInfo = hanjaMap.get(char);
                        return hanjaInfo ? hanjaInfo.huneum : `${char}(?)`;
                    }).join(' / ');
                    
                    const hangulWord = userWordbook.get(word) || getHangulWord(word); // Use stored pronunciation

                    contentHTML += `
                        <div class="wordbook-card" data-hanja="${word}" data-hangul="${hangulWord}" data-huneum="${huneumDetails}">
                            <div class="word-content word-hanja hanja-font" style="display: ${wordbookDisplayMode === 'hanja' ? 'block' : 'none'};">${word}</div>
                            <div class="word-content word-hangul" style="display: ${wordbookDisplayMode === 'hangul' ? 'block' : 'none'};">${hangulWord}</div>
                            <button class="remove-word-btn" data-word="${word}">×</button>
                        </div>
                    `;
                }
            }

            contentHTML += '</div></div>';
            wordbookView.innerHTML = contentHTML;

            wordbookView.querySelector('#home-btn-wordbook').addEventListener('click', goHome);
            const toggleBtn = wordbookView.querySelector('#toggle-wordbook-view-btn');
            if(toggleBtn) {
                toggleBtn.addEventListener('click', () => {
                    wordbookDisplayMode = wordbookDisplayMode === 'hanja' ? 'hangul' : 'hanja';
                    renderWordbook();
                });
            }
        }

        async function callGeminiVisionAPI(prompt, base64ImageData) {
            const model = "gemini-2.5-flash-preview-05-20";
            const apiKey = "";
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;

            const payload = {
                contents: [
                    {
                        role: "user",
                        parts: [
                            { text: prompt },
                            {
                                inlineData: {
                                    mimeType: "image/png",
                                    data: base64ImageData.split(',')[1]
                                }
                            }
                        ]
                    }
                ],
            };

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) throw new Error(`API Error: ${response.status}`);
                const result = await response.json();
                if (result.candidates && result.candidates[0]?.content?.parts?.[0]?.text) {
                    return result.candidates[0].content.parts[0].text;
                }
                return "AI로부터 피드백을 받지 못했습니다.";
            } catch (error) {
                console.error("AI Vision API Error:", error);
                return `AI 채점에 실패했습니다: ${error.message}`;
            }
        }


        function setupEventListeners() {
            document.body.addEventListener('click', async (e) => {
                const pajaAnimateBtn = e.target.closest('.paja-animate-btn');
                if (pajaAnimateBtn) {
                    e.stopPropagation();
                    const pajaContainer = pajaAnimateBtn.closest('.flex-shrink-0').querySelector('.paja-animation-container');
                    if (pajaContainer && !pajaContainer.classList.contains('animate')) {
                        pajaContainer.classList.add('animate');
                        setTimeout(() => pajaContainer.classList.remove('animate'), 2000);
                    }
                }

                const cardBackEl = e.target.closest('.card-back-content, #detail-card-content');
                if (cardBackEl) {
                    const relatedCardContainer = e.target.closest('.related-hanja-card');
                    if (relatedCardContainer) {
                        e.stopPropagation();
                        try {
                            const hanjaObject = JSON.parse(relatedCardContainer.dataset.hanja);
                            showNetworkView(hanjaObject.hanja);
                        } catch (err) {
                            console.error("Failed to parse hanja data from related card:", relatedCardContainer.dataset.hanja, err);
                        }
                        return;
                    }
                }

                const aiMnemonicBtn = e.target.closest('.ai-mnemonic-btn');
                if (aiMnemonicBtn) {
                    e.stopPropagation();
                    if (!currentHanjaData) return;
                    const loader = aiMnemonicBtn.previousElementSibling;
                    const outputDiv = loader.previousElementSibling;
                    loader.classList.remove('hidden');
                    aiMnemonicBtn.disabled = true;
                    const prompt = `한자 '${currentHanjaData.hanja}' (${currentHanjaData.huneum})를 쉽게 외울 수 있는 창의적이고 기발한 암기법을 한두문장으로 알려줘.`;
                    const result = await callGeminiAPI(prompt);
                    outputDiv.textContent = result;
                    loader.classList.add('hidden');
                    aiMnemonicBtn.disabled = false;
                }
                
                const removeBtn = e.target.closest('.remove-word-btn');
                if (removeBtn) {
                    e.stopPropagation();
                    const word = removeBtn.dataset.word;
                    if (userWordbook.has(word)) {
                        userWordbook.delete(word);
                        await saveDataToFirestore();
                        renderWordbook();
                    }
                }
                
                const wordbookCard = e.target.closest('.wordbook-card');
                if (wordbookCard) {
                    e.stopPropagation();
                    const wordData = {
                        hanja: wordbookCard.dataset.hanja,
                        hangul: wordbookCard.dataset.hangul,
                        huneum: wordbookCard.dataset.huneum,
                    };
                    showWordbookDetailView(wordData);
                }
            });

            document.getElementById('prev-btn').addEventListener('click', () => navigateCard(-1));
            document.getElementById('next-btn').addEventListener('click', () => navigateCard(1));
            
            const sortBtn = document.getElementById('sort-btn');
            const shuffleBtn = document.getElementById('shuffle-btn');

            sortBtn.classList.add('sort-toggle-btn', 'active');
            shuffleBtn.classList.add('sort-toggle-btn');

            shuffleBtn.addEventListener('click', () => {
                if (shuffleBtn.classList.contains('active')) return;
                shuffleBtn.classList.add('active');
                sortBtn.classList.remove('active');
                filteredHanjaData.sort(() => Math.random() - 0.5);
                currentIndex = 0;
                resetCardView(updateCard);
            });

            sortBtn.addEventListener('click', () => {
                if (sortBtn.classList.contains('active')) return;
                sortBtn.classList.add('active');
                shuffleBtn.classList.remove('active');
                filteredHanjaData.sort((a, b) => a.no - b.no);
                currentIndex = 0;
                resetCardView(updateCard);
            });

            correctBtn.addEventListener('click', () => markAnswer(true));
            incorrectBtn.addEventListener('click', () => markAnswer(false));
            
            card.addEventListener('click', (e) => {
                const target = e.target;
                if (target.closest('button, a, .small-card-container')) return;

                if (currentMode === 'write' && !isFlipped && target.closest('#start-write-area')) {
                    isFlipped = true;
                    card.classList.add('is-flipped');
                    setTimeout(() => initializeWriteCanvas('write-canvas'), 400); 
                    return;
                }
                
                if (currentMode === 'read') {
                    isFlipped = !isFlipped;
                    card.classList.toggle('is-flipped');
                    correctBtn.classList.toggle('invisible', !isFlipped);
                    incorrectBtn.classList.toggle('invisible', !isFlipped);
                }
            });

            document.querySelector('.control-panel #mode-selector').addEventListener('click', (e) => { 
                const button = e.target.closest('button');
                if (!button) return;
                const mode = button.dataset.mode; 

                if (mode && mode !== currentMode) {
                    if ((currentMode === 'read' || currentMode === 'write') && (mode !== 'read' && mode !== 'write')) {
                        mainLearningState = {
                            mode: currentMode,
                            level: currentLevel,
                            index: currentIndex,
                            data: [...filteredHanjaData]
                        };
                    }

                    document.querySelectorAll('.control-panel #mode-selector button').forEach(btn => btn.classList.remove('active')); 
                    button.classList.add('active'); 
                    
                    if (mode === 'type') {
                        currentMode = mode;
                        showTypeLearningView();
                    } else if (mode === 'quiz') {
                        currentMode = mode;
                        startQuiz();
                    } else if (mode === 'wordbook') {
                        currentMode = mode;
                        renderWordbook();
                        showView('wordbook-view');
                    } else if (mode === 'news-link') {
                        currentMode = mode;
                        showView('news-link-view');
                    } else if (mode === 'study') {
                        currentMode = mode;
                        showStudyView();
                    } else if (mode === 'read' || mode === 'write') {
                        if (currentMode === 'read' || currentMode === 'write') {
                            currentMode = mode;
                            resetCardView(updateCard);
                        } else {
                            goHome(); 
                            setTimeout(() => {
                                currentMode = mode;
                                updateCard();
                            }, 10);
                        }
                    }
                } 
            });

            document.querySelector('.control-panel #level-selector').addEventListener('click', (e) => {
                const button = e.target.closest('button');
                if(button && button.dataset.level) filterCards(button.dataset.level);
            });
            
            typeLearningView.addEventListener('click', async (e) => {
                const cardContainer = e.target.closest('.small-card-container');
                const repCard = e.target.closest('.representative-card');
                const returnBtn = e.target.closest('.return-to-study-btn');
                const storyBtn = e.target.closest('.ai-story-btn');

                if (returnBtn) { e.stopPropagation(); goHome(); return; }
                if (repCard || cardContainer) {
                    e.stopPropagation();
                    const cardEl = repCard || cardContainer.querySelector('.small-card');
                    const dataAttribute = (repCard || cardContainer).dataset.hanja;

                    if (cardEl.classList.contains('is-flipped') || repCard) {
                        try {
                            const hanjaObject = JSON.parse(dataAttribute);
                            if (hanjaObject) {
                                typeViewScrollPos = window.scrollY;
                                showDetailView(hanjaObject, 'type-learning-view');
                            }
                        } catch(err) {
                            console.error("Failed to parse hanja data from type view card:", dataAttribute, err);
                        }
                    } else {
                        cardEl.classList.add('is-flipped');
                    }
                    return;
                }
                
                if (storyBtn) {
                    e.stopPropagation();
                    const groupContainer = storyBtn.closest('.type-group-container');
                    const typeNo = groupContainer.id.split('-')[2];
                    const loader = document.getElementById(`ai-story-loader-${typeNo}`);
                    const outputDiv = document.getElementById(`ai-story-output-${typeNo}`);
                    
                    const hanjaElements = groupContainer.querySelectorAll('[data-hanja]');
                    const hanjaList = Array.from(hanjaElements).map(el => {
                        const data = JSON.parse(el.dataset.hanja);
                        return `- ${data.hanja} (${data.huneum})`;
                    }).join('\n');

                    loader.classList.remove('hidden'); storyBtn.disabled = true;
                    const prompt = `아래 한자들을 모두 사용하여, 기억하기 쉬운 짧은 이야기를만들어줘. 각 한자의 뜻과 소리를 이야기에 자연스럽게 녹여줘.\n\n한자 목록:\n${hanjaList}`;
                    const result = await callGeminiAPI(prompt);
                    outputDiv.textContent = result;
                    loader.classList.add('hidden'); storyBtn.disabled = false;
                }
            });


            document.getElementById('home-btn-news-link').addEventListener('click', goHome);
            document.getElementById('analyze-clipboard-btn').addEventListener('click', analyzeFromClipboard);

            // Quiz Listeners
            document.getElementById('home-btn-quiz-mode').addEventListener('click', goHome);
            document.getElementById('quiz-current-scope-btn').addEventListener('click', () => {
                quizSourceData = [...filteredHanjaData];
                document.getElementById('quiz-mode-panel').classList.add('hidden');
                document.getElementById('quiz-setup-panel').classList.remove('hidden');
            });
            document.getElementById('quiz-writing-btn').addEventListener('click', startWritingQuiz);
            
            function renderQuizTypeSelection() {
                const typeSelectorBar = document.getElementById('quiz-type-selector-bar');
                const uniqueTypes = [...new Set(hanjaData.map(h => h.typeNo))].filter(Boolean).sort((a, b) => a - b);
                const typeGroups = [];
                const groupSize = 20;
                const maxType = Math.max(...uniqueTypes);
                for (let i = 1; i <= maxType; i += groupSize) {
                    const start = i;
                    const end = Math.min(i + groupSize - 1, maxType);
                    if (uniqueTypes.some(t => t >= start && t <= end)) {
                        typeGroups.push({start, end});
                    }
                }
                
                typeSelectorBar.className = 'control-panel mb-6';
                const buttonsHTML = typeGroups.map(group => 
                    `<button class="quiz-type-select-btn py-4 px-3" data-start-type="${group.start}" data-end-type="${group.end}">
                        ${group.start}-${group.end}
                    </button>`
                ).join('');
                typeSelectorBar.innerHTML = `<div class="flex overflow-x-auto">${buttonsHTML}</div>`;
            }

            document.getElementById('quiz-by-type-btn').addEventListener('click', () => {
                renderQuizTypeSelection();
                document.getElementById('quiz-mode-panel').classList.add('hidden');
                document.getElementById('quiz-type-selection-panel').classList.remove('hidden');
            });
            
            document.getElementById('back-to-quiz-mode-btn').addEventListener('click', () => {
                document.getElementById('quiz-type-selection-panel').classList.add('hidden');
                document.getElementById('quiz-mode-panel').classList.remove('hidden');
            });

            document.getElementById('quiz-type-selection-panel').addEventListener('click', (e) => {
                const target = e.target.closest('.quiz-type-select-btn');
                if (target) {
                    const startType = parseInt(target.dataset.startType, 10);
                    const endType = parseInt(target.dataset.endType, 10);
                    quizSourceData = hanjaData
                        .filter(h => h.typeNo >= startType && h.typeNo <= endType)
                        .sort((a, b) => a.no - b.no);
                    document.getElementById('quiz-type-selection-panel').classList.add('hidden');
                    document.getElementById('quiz-setup-panel').classList.remove('hidden');
                }
            });

            const quizSlider = document.getElementById('quiz-slider');
            const quizCountLabel = document.getElementById('quiz-count-label');
            quizSlider.addEventListener('input', (e) => {
                selectedQuizCount = parseInt(e.target.value, 10);
                quizCountLabel.textContent = selectedQuizCount;
            });
            document.getElementById('start-quiz-btn').addEventListener('click', () => {
                initializeQuiz(selectedQuizCount, true);
            });
            document.getElementById('retry-quiz-btn').addEventListener('click', () => {
                document.getElementById('quiz-end-panel').classList.add('hidden');
                initializeQuiz(quizData.length, true);
            });
            document.getElementById('home-btn-quiz-setup').addEventListener('click', goHome);
            document.getElementById('home-btn-quiz').addEventListener('click', goHome);
            document.getElementById('home-btn-quiz-end').addEventListener('click', goHome);
            document.getElementById('home-btn-writing-quiz').addEventListener('click', goHome);
            
            // --- Writing Quiz Listeners ---
            document.getElementById('clear-writing-quiz-canvas-btn').addEventListener('click', () => {
                const canvas = document.getElementById('writing-quiz-canvas');
                const ctx = canvas.getContext('2d');
                const dpr = window.devicePixelRatio || 1;
                ctx.clearRect(0, 0, canvas.width / dpr, canvas.height / dpr);
                document.getElementById('writing-quiz-answer-display').textContent = '';
                
                document.getElementById('check-writing-quiz-answer-btn').classList.remove('hidden');
                document.getElementById('writing-quiz-mark-btns').classList.add('hidden');
            });

            document.getElementById('check-writing-quiz-answer-btn').addEventListener('click', () => {
                const answerDisplay = document.getElementById('writing-quiz-answer-display');
                const hanjaWord = writingQuizData[currentWritingQuizIndex];
                answerDisplay.textContent = hanjaWord;

                document.getElementById('check-writing-quiz-answer-btn').classList.add('hidden');
                document.getElementById('writing-quiz-mark-btns').classList.remove('hidden');
            });
            
            document.getElementById('next-writing-quiz-btn').addEventListener('click', () => {
                currentWritingQuizIndex++;
                loadNextWritingQuizQuestion();
            });

            const writingQuizMarkAndNext = (isCorrect) => {
                // In a real app, you might want to mark individual hanja in the word.
                // For simplicity here, we'll just move to the next question.
                currentWritingQuizIndex++;
                loadNextWritingQuizQuestion();
            };

            document.getElementById('writing-quiz-correct-btn').addEventListener('click', () => writingQuizMarkAndNext(true));
            document.getElementById('writing-quiz-incorrect-btn').addEventListener('click', () => writingQuizMarkAndNext(false));


            // --- Expert Write Canvas Listeners (v2) ---
            let isDrawing = false;
            let activeCanvas = null;
            let lastPos = { x: 0, y: 0 };

            function getPosition(event, canvas) {
                const rect = canvas.getBoundingClientRect();
                const touch = event.touches ? event.touches[0] : event;
                return { x: touch.clientX - rect.left, y: touch.clientY - rect.top };
            }

            function handleMove(e) {
                if (!isDrawing) return;
                e.preventDefault();

                const currentPos = getPosition(e, activeCanvas);
                const ctx = activeCanvas.getContext('2d');
                
                ctx.beginPath();
                ctx.moveTo(lastPos.x, lastPos.y);
                ctx.lineTo(currentPos.x, currentPos.y);
                ctx.stroke();
                
                lastPos = currentPos;
            }

            function handleEnd(e) {
                if (!isDrawing) return;
                e.preventDefault();
                isDrawing = false;

                document.removeEventListener('mousemove', handleMove);
                document.removeEventListener('touchmove', handleMove);
                document.removeEventListener('mouseup', handleEnd);
                document.removeEventListener('touchend', handleEnd);
            }

            function handleStart(e) {
                const canvas = e.target.closest('#write-canvas, #writing-quiz-canvas');
                if (!canvas) return;

                e.preventDefault();
                activeCanvas = canvas;
                isDrawing = true;
                lastPos = getPosition(e, activeCanvas);

                document.addEventListener('mousemove', handleMove, { passive: false });
                document.addEventListener('touchmove', handleMove, { passive: false });
                document.addEventListener('mouseup', handleEnd, { passive: false });
                document.addEventListener('touchend', handleEnd, { passive: false });
            }

            document.body.addEventListener('mousedown', handleStart);
            document.body.addEventListener('touchstart', handleStart, { passive: false });
            
            mainView.addEventListener('click', (e) => {
                const target = e.target.closest('button');
                if(!target) return;

                switch(target.id) {
                    case 'home-btn-write':
                        resetCardView(updateCard);
                        break;
                    case 'clear-canvas-btn':
                        const canvas = document.getElementById('write-canvas');
                        if(canvas) {
                            const ctx = canvas.getContext('2d');
                            const dpr = window.devicePixelRatio || 1;
                            ctx.clearRect(0, 0, canvas.width / dpr, canvas.height / dpr);
                            document.getElementById('stroke-guide-canvas').getContext('2d').clearRect(0, 0, canvas.width, canvas.height);
                        }
                        break;
                    case 'show-answer-btn':
                        if(!currentHanjaData) return;
                        const answerDisplay = document.getElementById('write-answer-display');
                        if (answerDisplay) {
                            answerDisplay.textContent = currentHanjaData.hanja;
                            answerDisplay.classList.remove('hidden');
                            document.getElementById('write-initial-controls').classList.add('hidden');
                            document.getElementById('write-check-buttons').classList.remove('hidden');
                        }
                        break;
                    case 'stroke-order-btn':
                        if (!currentHanjaData || !strokeData[currentHanjaData.hanja]) {
                            showModal('이 한자의 필순 데이터가 없습니다.');
                            return;
                        }
                        animateStrokeOrder(currentHanjaData.hanja);
                        document.getElementById('write-initial-controls').classList.add('hidden');
                        document.getElementById('write-check-buttons').classList.remove('hidden');
                        break;
                    case 'write-correct-btn':
                        markAnswer(true, true);
                        break;
                    case 'write-incorrect-btn':
                        markAnswer(false, true);
                        break;
                }
            });


            document.getElementById('network-shortcut-btn').addEventListener('click', () => {
                if (currentHanjaData) {
                    showNetworkView(currentHanjaData.hanja);
                } else {
                    showModal("네트워크를 표시할 한자를 먼저 선택해주세요.");
                }
            });

            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'hidden') {
                    if (sessionStartTime && userId) { 
                        const elapsedTime = Date.now() - sessionStartTime;
                        learningStats.totalTime = (learningStats.totalTime || 0) + elapsedTime;
                        saveDataToFirestore(); 
                    }
                } else {
                    sessionStartTime = Date.now(); 
                }
            });
        }
        
        async function getPronunciationsForNewWords(newWords) {
            const prompt = `다음 한자 단어 목록의 정확한 한글 발음을 JSON 형식으로 알려줘. 각 한자 단어를 key로, 한글 발음을 value로 해야 해. 다른 설명은 절대 추가하지 마. 단어: ${newWords.join(', ')}`;
            const resultText = await callGeminiAPI(prompt);
            try {
                // The API might return the JSON wrapped in markdown ```json ... ```
                const cleanJsonString = resultText.replace(/^```json\s*|```\s*$/g, '');
                return JSON.parse(cleanJsonString);
            } catch (e) {
                console.error("Failed to parse AI response as JSON:", resultText);
                // Fallback for each word if batch fails
                const pronunciations = {};
                for (const word of newWords) {
                    pronunciations[word] = getHangulWord(word); // Use old method as fallback
                }
                return pronunciations;
            }
        }

        async function analyzeFromClipboard() {
            try {
                const text = await navigator.clipboard.readText();
                if (!text.trim()) {
                    showModal("클립보드에 복사된 텍스트가 없습니다.");
                    return;
                }
                
                const hanjaRegex = /[\u4e00-\u9fa5]{2,}/g;
                let foundWords = text.match(hanjaRegex);

                if (!foundWords || foundWords.length === 0) {
                    showModal("한자 단어를 찾지 못했습니다.");
                    return;
                }
                
                const uniqueWords = [...new Set(foundWords)];
                const newWords = uniqueWords.filter(word => !userWordbook.has(word));

                if (newWords.length === 0) {
                    currentMode = 'wordbook';
                    document.querySelectorAll('.control-panel #mode-selector button').forEach(btn => btn.classList.remove('active')); 
                    document.querySelector(`button[data-mode="wordbook"]`)?.classList.add('active');
                    renderWordbook();
                    showView('wordbook-view');
                    return;
                }

                showModal("<p>새로운 단어의 정확한 발음을 AI로 분석 중입니다...</p>", "분석중", []);

                const pronunciations = await getPronunciationsForNewWords(newWords);
                
                Object.keys(pronunciations).forEach(hanjaWord => {
                    userWordbook.set(hanjaWord, pronunciations[hanjaWord]);
                });

                await saveDataToFirestore();
                
                // Close loading modal and navigate to wordbook
                document.getElementById('custom-modal-overlay').classList.add('hidden');
                currentMode = 'wordbook';
                document.querySelectorAll('.control-panel #mode-selector button').forEach(btn => btn.classList.remove('active')); 
                document.querySelector('.control-panel #mode-selector button[data-mode="wordbook"]')?.classList.add('active');
                renderWordbook();
                showView('wordbook-view');

            } catch (err) {
                console.error('클립보드 읽기 실패:', err);
                document.getElementById('custom-modal-overlay').classList.add('hidden'); // Hide loading modal on error
                if (err.name === 'NotAllowedError') {
                    showModal("클립보드 접근 권한이 필요합니다. 브라우저의 주소창 왼쪽의 아이콘을 클릭하여 클립보드 권한을 '허용'으로 변경한 후 다시 시도해주세요.", "권한 필요");
                } else {
                    showModal("클립보드에서 텍스트를 가져오는 데 실패했습니다. 브라우저가 이 기능을 지원하는지 확인해주세요.");
                }
            }
        }
        
        // --- Study View ---
        async function showStudyView() {
            showView('study-view');
            renderStudyView();
        }

        async function renderStudyView() {
            studyView.innerHTML = `
                <div class="w-full max-w-4xl mx-auto">
                    <div class="flex justify-between items-center mb-6">
                        <h1 class="text-3xl font-bold text-text-main">📺 한자 공부 영상</h1>
                        <button id="home-btn-study" class="btn-neumorphic py-3 px-5">🏠 학습 복귀</button>
                    </div>
                    <div id="video-list" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
                        <p class="text-text-light col-span-full text-center">영상 목록을 불러오는 중입니다...</p>
                    </div>
                </div>`;

            studyView.querySelector('#home-btn-study').addEventListener('click', goHome);

            const videoListEl = studyView.querySelector('#video-list');
            try {
                 const videos = [
                    { "title": "쓰쓰 일본어", "url": "https://youtube.com/shorts/Nn4Hn7EaI94?si=KRNN1dBBcMGy2wmJ" },
                    { "title": "한자 학습 영상", "url": "https://youtu.be/q2M42GXbV4Y?si=S-Ju1V3fYSayb8jS" }
                ];

                if (videos && videos.length > 0) {
                    videoListEl.innerHTML = ''; // Clear loading message
                    videos.forEach(video => {
                        const url = new URL(video.url);
                        let videoId;
                        if (url.hostname === 'youtu.be') {
                            videoId = url.pathname.slice(1);
                        } else {
                            videoId = url.searchParams.get('v');
                            if (!videoId && url.pathname.includes('/shorts/')) {
                                videoId = url.pathname.split('/shorts/')[1];
                            }
                        }
                        
                        if (videoId) {
                            const videoCard = document.createElement('div');
                            videoCard.className = 'stat-card';
                            videoCard.innerHTML = `
                                <div class="aspect-video mb-2">
                                    <iframe class="w-full h-full rounded-lg" src="https://www.youtube.com/embed/${videoId}" title="${video.title}" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                                </div>
                                <h3 class="text-text-light font-bold text-sm">${video.title}</h3>
                            `;
                            videoListEl.appendChild(videoCard);
                        }
                    });
                } else {
                    videoListEl.innerHTML = '<p class="text-text-light col-span-full text-center">영상을 찾을 수 없습니다.</p>';
                }
            } catch (error) {
                console.error("Error fetching or rendering videos:", error);
                videoListEl.innerHTML = '<p class="text-text-light col-span-full text-center">영상 목록을 불러오는 데 실패했습니다.</p>';
            }
        }


        async function main() {
            await fetchAllData();
            setupEventListeners();
            setupNetworkViewListeners();

            onAuthStateChanged(auth, (user) => {
                if (user) {
                    userId = user.uid;
                    userIdDisplay.textContent = `클라우드 ID: ${userId}`;
                    loadingStatus.textContent = "데이터 로딩중...";
                    setupFirestoreListener(); 
                } else {
                    userId = null;
                    if (firestoreUnsubscribe) {
                        firestoreUnsubscribe();
                        firestoreUnsubscribe = null;
                    }
                    authView.classList.remove('hidden-view');
                    mainView.classList.add('hidden-view');
                }
            });

            try {
                if (!auth.currentUser) {
                    const authToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
                    if (authToken) {
                        await signInWithCustomToken(auth, authToken);
                    } else {
                        await signInAnonymously(auth);
                    }
                }
            } catch (error) {
                console.error("Firebase Authentication Error:", error);
                loadingStatus.textContent = "인증 실패. 새로고침 해주세요.";
            }
        }

        main();
    </script>
</body>
</html>

